定义链表的结构体：

struct ListNode{
    int val;        //节点存储的元素
    ListNode *next; //指向下一个节点
    ListNode(0) : val(0), next(null){}
    ListNode(int x) : val(x), next(null){} //节点的构造函数

};

链表分类：单链表，双链表，循环链表


常见链表题目：
203 移除链表元素 https://leetcode-cn.com/problems/remove-linked-list-elements/
206.反转链表
19.删除链表的倒数第N个节点
链表相交
142题.环形链表II



 203 移除链表元素


删除链表元素的操作：cur->next = cur->next->next。再释放该节点空间即可。在c++中不释放空间也是可以的。
操作一：直接在原来链表中删除，
操作二：新建一个虚拟头节点

思路一，直接使用原来的链表进行删除操作：
1.如果删除的节点是头节点，只需要将头节点向后移一位，将下一个节点返回即可。
2.如果删除的节点不是头节点，则将cur->next = cur->next->next

class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        //删除头节点        while(head==NULL || head->val == val){            ListNode *tmp = head;            head = head->next;            delete tmp;        }                //删除的不是头节点        ListNode *cur = head;        while(cur && cur->val != val){            if(cur->next->val ==val ){                ListNode *tmp = cur->next;                cur->next = tmp->next;                delete tmp;                }else{                cur = cur->next;            }        }        return head;    }}思路二：新建一个虚拟头节点class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        ListNode *headtmp = new ListNode(-1);        headtmp->next = head;        ListNode *cur = headtmp;        while(cur->next){            if(cur->next->val == val){                ListNode *tmp = cur->next;                cur->next = tmp->next;                delete tmp;            }else{                cur = cur->next;            }        }        head = headtmp->next;        delete headtmp;        return head;    }}206.反转链表


思路：三指针法迭代法。通过改变链表的指针指向，让链表反转。
1.首先建立一个pre初始化null，一个cur指向头节点。
2.首先把cur->next保存下来，设为next。链表反转后cur->next就变成pre了。那下一个cur变成pre，next就变成下一个cur。
1 -> 2 -> 3 -> 4 -> null

null    1 -> 2 -> 3 -> 4 -> null
pre    cur  next

null <- 1    2  -> 3
 pre   cur  next

null <- 1    2  -> 3
        pre  cur  next
.......

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL) return NULL;
        ListNode *pre = NULL;
        ListNode *cur = head;
        while(cur){
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};

//思路二：尾递归方法，该方法还是和三指针法逻辑类似，只是用递归法来做。同样将cur==NULL作为循环结束，不断将cur指向pre的过程。
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return Reverse(NULL, head);
    }
    ListNode *Reverse(ListNode *pre, ListNode *cur){
        if(cur == NULL) return pre;
        ListNode *next = cur -> next;
        cur->next = pre;
        return Reverse(pre, next);
    }
}

19.删除链表的倒数第N个节点


给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？

思路：快慢指针的方法，建立一个虚拟节点。
1.我们先建立一个空指针，通过建立两个指针fast，slow，从空指针开始。因为要删除倒数第n个节点，我们先让fast走n+1步
2.当fast != NULL 时fast和slow同时移动，当fast==NULL时，slow的下一个节点就是要删除的节点。

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *fast = dummy;
        ListNode *slow = dummy;
        while(n-- && fast != NULL){
            fast = fast->next;
        }
        fast = fast -> next;
        while(fast != NULL){
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};

思考：快慢指针的方法，直接在链表上操作。
1.如果head==NULL 直接返回NULL。
1.建立两个指针fast，slow=head， 因为要删除倒数第n个节点，我们先让fast走n步。如果fast此时是NULL，则说明链表没有n个元素长，则直接返回head->next;
2.当fast != NULL 时fast和slow同时移动，当fast==NULL时，slow的下一个节点就是要删除的节点。
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return NULL;
        ListNode *fast = head;
        ListNode *slow = head;
        for(int i=0;i<n;i++){
                fast = fast->next;
        }
        if(fast==NULL)
            return head->next;


        while(fast ->next){
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next; //fast==NULL时slow的next就是要删除的元素
        return head;
    }
};


面试题 02.07. 链表相交

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

题目中说求两个链交点的起始节点，因此不是值相同，而是指针相同。简单意思就是节点既在headA上也在headB上。

  4->1->8->4->5
    ^
    |
 5->0 

思路一：
1.先遍历两个链表的长度，lenA，lenB。求出链表长度差diff，先让长度长的链表走diff步。
2.然后两个链表同时走，如果指针指的值相同表示是环首，则返回。如果指针访问到最后都没有相同则返回NULL。
时间复杂度O(m+n)，空间复杂度O(1)

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL || headB==NULL) return NULL;
        ListNode *t1 = headA;
        ListNode *t2 = headB;
        int lenA = 0;
        int lenB = 0;
        while(t1){
            lenA++;
            t1 = t1->next;
        }
        while(t2){
            lenB++;
            t2 = t2->next;
        }


        t1 = headA;
        t2 = headB;
        if(lenA>lenB){
            int diff = lenA-lenB;
            while(diff--) t1=t1->next;
        }else{
            int diff = lenB-lenA;
            while(diff--) t2=t2->next;
        }


        while(t1 && t2){
            if(t1 == t2) return t1;
            t1 = t1->next;
            t2 = t2->next;
        }
        return NULL;
    }
};

如果链表相交的部分长度是c，headA的链表不相加长度a，headB的链表不相交长度b，则 a + c + b = b + c + a
如果链表不相交，则 a + b = b + a.

所以思路二是：将两个链表前后链接在一起，acb，bca。然后遍历这个新的链表，如果两个链表有相交，则一定在新链表的相同长度处。

设置两个指针同时从headA，headB的头出发，然后一直对比是否节点相同，如果不同则一直后移一位，如果headA.next是null，则表明headA到头了，可以从headB开始，如果headB.next是null，则表明headB到头了，可以从headA开始。如果中间相交则返回，如果最终都遍历完则表明不相交，返回NULL。

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {


      if(headA == NULL || headB == NULL) return NULL;


      ListNode *h1 = headA;
      ListNode *h2 = headB;
      while(h1 != h2){
          h1 = h1 == NULL ? headB : h1->next;
          h2 = h2 == NULL ? headA : h2->next;
      }
      return h1;
    }
};

142题 .环形链表II
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

进阶：
你是否可以使用 O(1) 空间解决此题？
 
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

思路一：

读题说返回链表开始入环的第一个节点, 如果链表无环则返回 null。所以第一步是需要判断是否链表有环，第二步是对有环链表返回第一个入环的节点。

第一个问题：判断是否有环可以使用快慢指针fast，slow，fast每次走两步，慢指针每次走一步，如果有环一定会相遇。
第二个问题：说明快慢指针相遇的地方不一定是环的首节点，假设从链表起始点到环的起始点长度是a，环起始点到相遇点是b，相遇点到环的起始点是c。

———x———\——\
        \  \  y
     z   \— \ 相遇

相遇时slow慢指针走了x+y,  快指针fast走了x+n(y+z)+y。n是fast在圈里走了n圈。因为fast指针每次走2步，slow慢指针每次走一步，则快指针走的节点数是慢指针的2倍。
 x+n(y+z)+y = 2 * (x +y)  =>  n(y+z) = x+y  => (n-1)*(y+z) + z = x。  

如果fast快指针只走了1圈 n=1，则x = z,
则说明设置两个指针idx1从链表起始点开始走，idx2从相遇点开始走，那他们相遇的地方就是链表的起始点。
如果fast快指针走了n圈，则是fast在圈里转了n圈后才遇到slow。效果和情况一一样。 
时间复杂度O(n)，空间复杂度O(1)

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
            if (slow == fast) {  //链表有环，此时在环中相遇
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2; // 返回环的入口
            }
        }
        return NULL;
    }
}; 
               
思路二：使用哈希表，将每个节点存到哈希表里，此处使用set结构，因为不需要去key有序，不需要存储value值。
时间复杂度O(n)，空间复杂度O(n)
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        std::unordered_set<ListNode *> set;
        while(head!=NULL){
            if(set.count(head)){
                return head;
            }
            set.insert(head);
            head = head->next;
        }
        return NULL;
    }
};


---------------------------------------------
0811
0812题目没有补充，需要周六日补充
811-00815补题，把链表补齐
