## 数组



数组是存放在**连续内存空间**上的相同类型的数据的集合。数组的下标都是从0开始。

c++中vetor和array是有区别的，vector是容器不是数组，底层是array。数组的元素是不能删除的只能覆盖

二维数组在内存空间地址也是连续的

#### **二分查找**

nums数组为**有序数组**，且**元素无重复**，可以通过二分查找找是否有该元素。

二分查找有很多边界条件要注意，1.比如是while(left < right)还是while(left <= right)，2.是right=middle还是right=middle-1.

写二分法，区间的定义有两种，左闭右闭[left, right]，或者左闭右开[left, right)。

**二分法第一种写法**

我们定义target在左闭右闭[left, right]的区间里。有以下两点：

1.while(left <= right)，要使用<=， 因为在区间里left==right是有意义的，所以用<=。

2.if(nums[mid] > target)，right=mid-1，因此我们已经知道nums[mid] 肯定不是target，则左区间下标的位置就是mid-1。

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left <= right){  // [left, right]
            int mid = left + (right - left) / 2;  //这种方式可以防止(left+right)溢出，超出整数限制
            if(nums[mid] > target)
                right = mid - 1;
            else if(nums[mid] < target)
                left = mid + 1;
            else
                return mid;
        }
        return -1;
    }
};
```

**二分法第二种写法**

我们定义target在左闭右开[left, right)的区间里。有以下两点：

1.while(left < right)，因为是左闭右开，left不会等于right，所以用<。

2.if(nums[mid] > target)，right=mid，因为当前的nums[mid] 不等于 target，去左区间查找，而区间定义是左闭右开，则左区间下标的位置就是mid。

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size();
        while(left < right){     // [left, right)
            int mid = left + (right - left) / 2;  //这种方式可以防止(left+right)溢出，超出整数限制
            if(nums[mid] > target)
                right = mid;
            else if(nums[mid] < target)
                left = mid + 1;
            else
                return mid;
        }
        return -1;
    }
};
```

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

```
示例 1:输入: nums = [1,3,5,6], target = 5  输出: 2
示例 2:输入: nums = [1,3,5,6], target = 2  输出: 1
```

**题意解析**

给定一个排序数组和目标值，如果找到返回下标，如果没找到返回该放的位置。被插入的位置有以下四种情况：

情况1.目标值插入到数组的首个数值之前

情况2.目标值插入到数组的全部数值之后

情况3.目标值和数组中某个元素相等，返回索引

情况4.目标值没找到，插入到某个元素之前

**暴力解法**

```C++
//时间复杂度O(n) 空间复杂度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i] >= target)
                return i;     //情况1，3，4
        }
        return nums.size();   //情况2
    }
};
```

**二分查找**

有序数组且无重复元素可以使用二分查找。

**二分查找第一种：左闭右闭**

```C++
//时间复杂度O(logn) 空间复杂度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while(left <= right){  //[left, right]
            int mid = left + (right - left) / 2;
            if(nums[mid] > target)
                right = mid - 1;  //[left, mid-1]
            else if(nums[mid] < target)
                left = mid + 1;   //[mid+1, right]
            else    
                return mid; 
        }
        //情况1.目标值插入到数组的首个数值之前 [0, -1]
        //情况2.目标值插入到数组的全部数值之后 [left, right] return right+1
		//情况3.目标值和数组中某个元素相等，返回索引  return mid
		//情况4.目标值没找到，插入到某个元素位置 [left, right] return right+1
        
        return right+1;
    }
};
```

**二分查找第一种：左闭右开**

```C++
//时间复杂度O(logn) 空间复杂度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){  //[left, right)
            int mid = left + (right - left) / 2;
            if(nums[mid] > target)
                right = mid;  //[left, middle)
            else if(nums[mid] < target)
                left = mid + 1;  //[middle+1, right)
            else    
                return mid;
        }
        //情况1.目标值插入到数组的首个数值之前 [0, 0)
        //情况2.目标值插入到数组的全部数值之后 [left, right) return right
		//情况3.目标值和数组中某个元素相等，返回索引  return mid
		//情况4.目标值没找到，插入到某个元素位置 [left, right) return right
        
        return right;
    }
};
```

#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**快慢指针**

```c++
//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int index=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i] != val)
                nums[index++] = nums[i];
        }
        return index;
    }
};
```

#### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

```
示例 1：输入：nums = [-4,-1,0,3,10]  输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**暴力排序**

```c++
//时间复杂度O(n+logn)
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        //每个数平方后，整个数组排序
        for(int i = 0; i < nums.size(); i++){
            nums[i] = nums[i]*nums[i];
        }
        sort(nums.begin(), nums.end());  //快排
        return nums;
    }
};
```

**双指针法**

数组是有序的，如果有负数，负数平方后就会变成最大值。那么数组的最大值都只会出现在数组的两端，不是左边就是右边，最小值都是在中间。

双指针，新建一个和nums相同长度的数组result，i指向起始位置，j指向终止位置，k指向result数组的终止位置。

`A[i]*A[i] < A[j]*A[j],那么result[k--] = A[j]*A[j];`

`A[i]*A[i] >= A[j]*A[j],那么result[k--] = A[i]*A[i];`

整体代码如下：

```C++
//时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> res(nums.size(), 0);
        int i = 0; j = nums.size()-1;
        int k = nums.size()-1;
        while(i <= j){
            if(nums[i] * nums[i] < nums[j] * nums[j]){
                res[k--] = nums[j] * nums[j];
                j--;
            }else{
                res[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return res;
    }
};
```

#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

难度：中等

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```
示例 1：输入：target = 7, nums = [2,3,1,2,4,3]  输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**暴力解法**

用两层for循环不断寻找符合条件的子序列，时间复杂度O(n^2)

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX;
        int subLen = 0;
        int sum = 0;
        for(int i=0;i<nums.size();i++){
            sum = 0;
            for(int j=i;j<nums.size();j++){
                sum+=nums[j];
                if(sum >= target){
                    subLen = j - i + 1;
                    if(subLen < res) 
                        res = subLen;
                }
            }
        }
        return res == INT_MAX ? 0:res;
    }
};
```

滑动窗口

针对滑动窗口，每次移动滑动窗口的起始位置和终止位置

```C++
//时间复杂度O(n), 空间复杂度O(1)
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res=INT_MAX;
        int sum=0;
        int sublen=0;
        int i=0;
        for(int j=0;j<nums.size();j++){
            sum+=nums[j];
            while(sum>=target){ //这里是while，每次更新i，不断判断子序列是否符合条件
                sublen=j-i+1;
                if(sublen < res)
                    res = sublen;
              	sum -= nums[i]; //i向前移动一位
            }
        }
        return res == INT_MAX ? 0 : res;  //如果result没有被赋值，则就是原值INT_MAX,不存在符合条件的子数组，返回 0
    }
};
```

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。


示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"
示例 3:

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char,int> m;
        for(char c: t) m[c]++;
        int count = t.size();
        int right = 0,left = 0;
        int len = INT_MAX,strStart = -1;
        while(right<s.size()) {
            if(m[s[right]] > 0){
                m[s[right]]--;
                right++;
                count--;
            } 
            while(count == 0) {
                if(right - left < len) {
                    len = right - left;
                    strStart = left;
                }
                if(m[s[left]] == 0){
                    m[s[left]]++;
                    left++;
                    count++;
                } 
            }
        }
        if(strStart == -1) return "";
        else return s.substr(strStart, len);
    }
};
```











