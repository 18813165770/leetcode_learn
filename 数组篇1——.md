## 数组



数组是存放在**连续内存空间**上的相同类型的数据的集合。数组的下标都是从0开始。

c++中vetor和array是有区别的，vector是容器不是数组，底层是array。数组的元素是不能删除的只能覆盖

二维数组在内存空间地址也是连续的

#### **二分查找**

nums数组为**有序数组**，且**元素无重复**，可以通过二分查找找是否有该元素。

二分查找有很多边界条件要注意，1.比如是while(left < right)还是while(left <= right)，2.是right=middle还是right=middle-1.

写二分法，区间的定义有两种，左闭右闭[left, right]，或者左闭右开[left, right)。

**二分法第一种写法**

我们定义target在左闭右闭[left, right]的区间里。有以下两点：

1.while(left <= right)，要使用<=， 因为在区间里left==right是有意义的，所以用<=。

2.if(nums[mid] > target)，right=mid-1，因此我们已经知道nums[mid] 肯定不是target，则左区间下标的位置就是mid-1。

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left <= right){  // [left, right]
            int mid = left + (right - left) / 2;  //这种方式可以防止(left+right)溢出，超出整数限制
            if(nums[mid] > target)
                right = mid - 1;
            else if(nums[mid] < target)
                left = mid + 1;
            else
                return mid;
        }
        return -1;
    }
};
```

**二分法第二种写法**

我们定义target在左闭右开[left, right)的区间里。有以下两点：

1.while(left < right)，因为是左闭右开，left不会等于right，所以用<。

2.if(nums[mid] > target)，right=mid，因为当前的nums[mid] 不等于 target，去左区间查找，而区间定义是左闭右开，则左区间下标的位置就是mid。

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size();
        while(left < right){     // [left, right)
            int mid = left + (right - left) / 2;  //这种方式可以防止(left+right)溢出，超出整数限制
            if(nums[mid] > target)
                right = mid;
            else if(nums[mid] < target)
                left = mid + 1;
            else
                return mid;
        }
        return -1;
    }
};
```

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

```
示例 1:输入: nums = [1,3,5,6], target = 5  输出: 2
示例 2:输入: nums = [1,3,5,6], target = 2  输出: 1
```

**题意解析**

给定一个排序数组和目标值，如果找到返回下标，如果没找到返回该放的位置。被插入的位置有以下四种情况：

情况1.目标值插入到数组的首个数值之前

情况2.目标值插入到数组的全部数值之后

情况3.目标值和数组中某个元素相等，返回索引

情况4.目标值没找到，插入到某个元素之前

**暴力解法**

```C++
//时间复杂度O(n) 空间复杂度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i] >= target)
                return i;     //情况1，3，4
        }
        return nums.size();   //情况2
    }
};
```

**二分查找**

有序数组且无重复元素可以使用二分查找。

**二分查找第一种：左闭右闭**

```C++
//时间复杂度O(logn) 空间复杂度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while(left <= right){  //[left, right]
            int mid = left + (right - left) / 2;
            if(nums[mid] > target)
                right = mid - 1;  //[left, mid-1]
            else if(nums[mid] < target)
                left = mid + 1;   //[mid+1, right]
            else    
                return mid; 
        }
        //情况1.目标值插入到数组的首个数值之前 [0, -1]
        //情况2.目标值插入到数组的全部数值之后 [left, right] return right+1
		//情况3.目标值和数组中某个元素相等，返回索引  return mid
		//情况4.目标值没找到，插入到某个元素位置 [left, right] return right+1
        
        return right+1;
    }
};
```

**二分查找第一种：左闭右开**

```C++
//时间复杂度O(logn) 空间复杂度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){  //[left, right)
            int mid = left + (right - left) / 2;
            if(nums[mid] > target)
                right = mid;  //[left, middle)
            else if(nums[mid] < target)
                left = mid + 1;  //[middle+1, right)
            else    
                return mid;
        }
        //情况1.目标值插入到数组的首个数值之前 [0, 0)
        //情况2.目标值插入到数组的全部数值之后 [left, right) return right
		//情况3.目标值和数组中某个元素相等，返回索引  return mid
		//情况4.目标值没找到，插入到某个元素位置 [left, right) return right
        
        return right;
    }
};
```

