## 贪心算法简单题

##### 455 分发饼干

##### 376 摆动序列

### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但ZJ是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```
示例 1:输入: g = [1,2,3], s = [1,1]  输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

示例 2:输入: g = [1,2], s = [1,2,3] 输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```


提示：

* 1 <= g.length <= 3 * 104
* 0 <= s.length <= 3 * 104
* 1 <= g[i], s[j] <= 231 - 1

**题意分析**

贪心算法的思路是在局部最优的情况下，可以通过局部最优达到全局最优。

本题是说为了满足更多的小孩，就不能造成饼干尺寸的浪费。大尺寸的饼干既可以满足大胃口的小孩，也可以满足小胃口的小孩，那么就应该优先满足大胃口的小孩。“局部最优”就是大饼干满足大胃口，“全局最优”就是尽可能喂饱更多的小孩。

**排序+贪心**

通过贪心策略，先对饼干和小孩数组做排序，然后从后往前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足的小孩的数量。

```c++
//时间复杂度O(logn)，空间复杂度O(1)
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());  
        sort(s.begin(), s.end());
        int index = s.size()-1;  //饼干的最大下标
        int result = 0;
        for(int i = g.size()-1; i >= 0; i--){
            if(index >= 0 && s[index] >= g[i]){
                result++;
                index--;
            }
        }
        return result;
    }
};
```

换一种思路，饼干能满足大胃口的孩子，那必然可以满足小胃口的孩子，同样是满足一个孩子，满足小胃口的孩子却不一定能满足大胃口的孩子。

所以先对饼干和小孩数组做排序，然后从小往大遍历饼干，如果小饼干满足不了小胃口的孩子那么肯定也满足不了大胃口的孩子，舍弃。如果满足了，那么就跳到下一个孩子，最后饼干都发完了，那么对满足几个孩子做统计。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());  
        sort(s.begin(), s.end());
        int index = 0;
        for(int i = 0; i < s.size(); i++){
            if(index < g.size() && s[i] >= g[index]){
                index++;
            }
        }
        return index;
    }
};
```

### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度：中等

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```
示例 1：输入：nums = [1,7,4,9,2,5]  输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：输入：nums = [1,17,5,10,13,15,10,5,16,8]  输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：输入：nums = [1,2,3,4,5,6,7,8,9]  输出：2
```


提示：

* 1 <= nums.length <= 1000
* 0 <= nums[i] <= 1000

**题意解析**

看到本题中求摆动序列的最长子序列的长度，首先想到的是动态规划的思路。

**动态规划**

本题中的一个思路是**首先预处理，然后去掉连续的重复数字**，

1.确定dp数组及下标含义：dp[i]表示从[0,i]的最长子序列

2.递归数组：如果是一正一负，则dp[i] = dp[i-1]+1, 否则也不需要去删除原数组中的值，直接dp[i] = dp[i-1]。

```c++
if((nums[i]*nums[i-1]) * (nums[i-1]*nums[i-2]) < 0)
	dp[i] = dp[i - 1] + 1;
else:
	dp[i] = dp[i-1];
```

3.初始化

从递推公式可以看出需要提前给出dp[0], dp[1]。然后for循环从2开始。dp[0]表示一个元素，则dp[0] = 1，如果提前**去重**过了，那么无论nums[1]是比nums[0]大还是小都可以，dp[1] = 2;

4.遍历顺序：从递推公式可以看出，遍历顺序是从前往后

5.举例推导：

输入：nums = [1,7,4,9,2,5]  输出：6

去重nums2 = [1,7,4,9,2,5] ，dp数组：

| 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |

返回dp[nums.size()-1]则是最终值。

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return 0;

        vector<int> newnums;
        newnums.push_back(nums[0]);
        for(int i=1;i<n;i++){
            if(nums[i] != nums[i-1])
                newnums.push_back(nums[i]);  //去掉重复的数字
        }

        int n2 = newnums.size();
        if(n2 <= 2) 
            return n2;
        vector<int> dp(n2, 0);
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2; i < n2; i++){
            if((newnums[i] - newnums[i-1])*(newnums[i-1]-newnums[i-2]) < 0)
                dp[i] = dp[i-1]+1;
            else
                dp[i] = dp[i-1];
        }
        return dp[n2-1];

    }
};
```

**贪心算法**

建立两个数组，使用up数组来确定递增的最长摆动序列长度，down数组来确定递减的最长摆动序列长度。只有一个数字时默认是1.

1. nums[i+1] > nums[i]：假设down[i]表示最长摆动序列的最远末尾元素下标i，那么遇到上升元素之后，up[i+1]=down[i]+1，这是因为up一定是在down之后的。

2. nums[i+1] < nums[i]：假设up[i]表示最长摆动序列的最远末尾元素下标i，那么遇到下降元素之后，down[i+1]=up[i]+1，这是因为down一定是在up之后的。

3. nums[i+1]=nums[i]：相同的元素则说明不上不下，不能用于任何序列，保持不变。

   举例：nums = [1,7,4,9,2,5]，演示如下：

   | i    | 0    | 1        | 2        | 3          | 4            | 5              |
   | ---- | ---- | -------- | -------- | ---------- | ------------ | -------------- |
   | nums | 1    | 7        | 4        | 9          | 2            | 5              |
   | up   | 1(1) | 2（1,7） | 2（1,7） | 4(1,7,4,9) | 4(1,7,4,9)   | 6(1,7,4,9,2,5) |
   |      | /    | \        | /        | \          | /            |                |
   | down | 1(1) | 1(1)     | 3(1,7,4) | 3(1,7,4)   | 5(1,7,4,9,2) | 5(1,7,4,9,2)   |

   ```C++
   class Solution {
   public:
       int wiggleMaxLength(vector<int>& nums) {
           int down = 1, up = 1;
           for(int i = 1; i < nums.size(); i++){
               if(nums[i] > nums[i-1])
                   up = down + 1;
               else if(nums[i] < nums[i-1])
                   down = up + 1;
           }    
           return nums.size() == 0 ? 0 : max(down, up);
       }
   };
   ```

   ### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

```
示例 1：输入：nums = [2,3,1,1,4]  输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：输入：nums = [3,2,1,0,4]  输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```


提示：

* 1 <= nums.length <= 3 * 1041
* 0 <= nums[i] <= 105

**题意解析**

**贪心算法**

本题的意思是说，想象你是在跳格子，格子里的数代表可以跳几次，只要格子的值不等于0，则肯定可以跳到最后。每次走到一个格子，检查你手上有的格子数量，和你当前所站在的格子数量那个大，就选择那个。而这个也是贪心的局部最优，每次选择可以跳的最大值，全局最优就是可以跳到最后。

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size()==0)
            return true;
        int cur=nums[0];  //i=0
        int i = 1;
        for(;cur != 0 && i<nums.size();i++){
            cur--;
            if(cur < nums[i])
                cur=nums[i];
        }
        return i == nums.size(); 
    }
};
```

**动态规划**

使用动态规划来分析：

1.确定dp数组及下标含义：dp[i]用来表示到下标i处，可以跳跃的最大长度dp[i]

2.递推函数：dp[i]取决于前一个dp[i-1]，如果前一个dp[i-1]跳到当前位置后剩余的跳跃数dp[i-1]-1,和当前位置的跳跃数nums[i]，取最大值就是可以跳跃的最大长度。当然本处有个条件就是dp[i-1]不能是0，如果是0，则无法跳到当前位置。

3.初始化dp[0] =  nums[0];

4.遍历顺序：从递推函数可以知道只取决于前一个dp位置，因此是从前往后遍历

5.举例推导：nums = [2,3,1,1,4] ， dp=[2,3,2,1,4]，如果顺利遍历完则说明可以跳到最后位置，返回true，如果中间有一个dp[i-1]等于0，则返回false。

动态规划代码：

```C++
//时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 0) return true;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        for(int i=1;i<nums.size();i++){
            if(dp[i-1] == 0)
                return false;
            dp[i] = max(nums[i], dp[i-1] - 1);
        }
        return true;
    }
};
```

优化代码：由于dp[i]只取决于dp[i-1]，因此可以使用滚动数组，只设置两个变量

```c++
//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 0) return true;
        vector<int> dp(2);
        dp[0] = nums[0];
        for(int i=1;i<nums.size();i++){
            if(dp[0] == 0)
                return false;
            dp[1] = max(nums[i], dp[0] - 1);
            dp[0] = dp[1];
        }
        return true;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

```
示例 1:输入: nums = [2,3,1,1,4]  输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:输入: nums = [2,3,0,1,4]  输出: 2
```


提示:

* 1 <= nums.length <= 104
* 0 <= nums[i] <= 1000

**题意解析**

本题是给定非负整数数组 nums，假设你总是可以到达数组的最后一个位置，问达到最后一个位置的最少的跳跃次数。本题和上一题的区别在于：一定可以达到最后位置，问最少跳跃次数。

**使用动态规划来分析**：

题目中给出**一定可以达到最后位置**，那么我们可以从末尾往前开始求最少的步数。新建一个dp数组，长度和nums数组等长，如果从末尾开始，俺么我们知道在最后一个位置的元素dp[nums.size()-1]的最少跳跃数是0，因为它就在最后一个位置。

1.dp数组及下标含义：dp[i]表示下标i达到最后位置所用的最少跳跃次数是dp[i]。

2.递推公式：在下标i处，如果下标i的位置的数nums[i] == j，则说明在nums[i]可以跳跃到的范围是[i+1,i+2,...i+j]，那么dp[i] = min(dp[i+1],dp[i+2]...dp[i+j]) + 1。

3.初始化dp[nums.size()-1] = 0;

4.遍历顺序从后往前的

5.举例

对于[2,3,0,1,4]：对应的dp数组[?,?,?,?,0]

从倒数第二位，对应的nums=1, 范围是走1步，因此dp[3] = 1;

从倒数第三位，对应的nums=0，表示不走，对应的dp[2]我们取个不影响结果的值dp[2]=*;

从倒数第四位，对应的nums=3, 范围是走3步，意思就是在下标[2,3,4]的范围内都可以走，那么dp[1] = min(dp[2], dp[3], dp[4]) + 1 =  1

到第一个位置，对应的nums=2,范围是走2步，对应的dp[0] = min(dp[1], dp[2]) + 1 = 2

**动规代码如下：**

```c++
class Solution {
    public int jump(int[] nums) {
        vector<int> dp(nums.size());
        for(int i=nums.size()-2;i>=0;i--)
            if(nums[i] == 0){  //如果有元素是0，则本身的跳跃式就是0，就走不到终点，设置一个最大值，
                dp[i] = INT_MAX;
                continue；
            }
        	minL = INT_MAX;
        	for(j = 1; j <= nums[i] && i+j < nums.length(); j++){
                minL = min(minL, dp[i+j]);
            }   //找到(i+1,i+2,...,i+j)范围内的dp最小值
        	if(minL == INT_MAX){
                dp[i] = minL;
                continue;
            }
        	dp[i] = min+1;
    	} 
    	return dp[0];
    }
}
```

### [1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

```
示例 1：输入：A = [4,2,3], K = 1  输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
示例 2：输入：A = [3,-1,0,2], K = 3  输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：输入：A = [2,-3,-1,5,-4], K = 2  输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
```


提示：

* 1 <= A.length <= 10000
* 1 <= K <= 10000
* -100 <= A[i] <= 100

**题意解析**

本题是给一个整数数组，可以将其中的k个元素A[i]变成-A[i]，使得最终数组和最大。

贪心的局部最优：让绝对值大的负数转成整数，数值最大，全局最优：整个数组和最大

如果负数都转成整数了，k>0，则此时是一个全正数的序列，只有让最小的值转负数，才能保持整个数组和最大。

具体的解题思路：

1.将整个数组按照**绝对值从大到小**排序

2.从前往后遍历，对负数的值取反，并且k--

3.如果k依然大于0，则反复将最后一个数（最小的数）不断取反。

4.全部数组值加和

```C++
class Solution {
public:
    static bool cmp(int a, int b){
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp); //1.将整个数组按照**绝对值从大到小**排序
        for(int i = 0; i < nums.size() && k > 0; i++){ //2.从前往后遍历，对负数的值取反，并且k--
            if(nums[i] < 0)
            {
                nums[i] *= -1;
                k--;
            }
        }
        if(k % 2 == 1) //3.如果k依然大于0，则反复将最后一个数（最小的数）不断取反。
            nums[nums.size() - 1] *= -1;

        int result = 0;  //4.全部数组值加和
        for(int num : nums)
            result += num;
        return result;
    }
};
```

#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

头条考过，难度：中等

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。

```
示例 1:输入: gas  = [1,2,3,4,5]  cost = [3,4,5,1,2]  输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

示例 2:输入: gas  = [2,3,4]  cost = [3,4,3]  输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

**题意解析**

**图像解法**

题目的意思：环上有N个加油站，每到一个站点i，可以加gas[i]的汽油，离开站点i需要cost[i]的汽油。问从那个节点开始走，可以绕一圈回到原位。

如果我们把站点加的油和离开消耗的油看作整体，将`sum = gas[i] - cost[i]`作为站点i的油量变化值。如果可以绕一圈回来，则肯定说明sum的累加和一直都是>0的。

我们把每个节点的油量变化值在坐标轴上显示出来。假设sum的变化是：

| sum  | 2    | 3    | -2   | -3   | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

如果我们把第一个点作为起点肯定不行，因为在过程中sum有变成<0，因此我们需要找一个起始位置start，使得从起始位置开始累加和一直都是大于等于0。

那么我们能找那个点呢？最低点。如果我们把sum中的最低点作为起始点，也就相当于把这个点作为坐标原点，相当于把整个图像向上平移。再加上整个数组是环形数组，则sum的取值变化是

| sum  | 5    | 6    | 1    | 0    | 5    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

另外：如果总油量`sum(gas[...]) < sum(cost[...])`，总油量小于总消耗量，则肯定无法到达起始位置的。

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size(); 
        int start = 0;  //一开始假设起始位置从0开始
        int sum = 0;
        int minSum = INT_MAX;  //统计最小的num，来找到起始位置
        for(int i = 0; i < n; i++){
            sum += (gas[i] - cost[i]);
            if(sum < minSum){
                minSum = sum;  //// 经过第 i 个站点后，使 sum 到达新低 所以站点 i + 1 就是最低点（起点）
                start = i + 1;
            }
        }
        
        if(sum < 0)  //总油量小于总消耗量
            return -1;  
        return start == n ? 0 : start;
    }
};
```

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

难度：困难

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

```
示例 1：输入：[1,0,2] 输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2：输入：[1,2,2]输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

**题意解析**

给一个评分数组，对每个孩子分发糖果，保证每个孩子最少1个糖果，如果孩子i的左边或者右边的打分比它高，需要多发最少一个糖果。问最少需要准备多少颗糖果。

这个题需要考虑每个孩子的左边和右边两种情况，只要rating[i] < rating[i-1]，或者rating[i] < rating[i+1]，则左右两边最少可以得到的糖果数就是：candy[i-1] = candy[i]+1，或者candy[i+1]=candy[i]+1。

本题我们针对从左到右和从右到左分两种情况分别讨论：

从左到右情况（右孩子>左孩子）：rating[0]初始化为1，i从1遍历，如果rating[i] > rating[i-1]， candy[i]=candy[i-1]+1。

从右到左情况（左孩子>右孩子）：由于从左到右我们已经得出一个candy[n-1]的值，那么i遍历从n-2开始，如果rating[i] > rating[i+1]，此时candy[i]其实有两个选择：一个选择是candy[i+1]+1，另一个选择是从左到右遍历的candy[i]。此时为了保证贪心，每个孩子获得的糖果既要大于左边也要大于右边，则取最大值。

`max(candy[i+1]+1, candy[i])`

C++代码如下：

```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> candy(n, 1);

        for(int i=1;i<n;i++){
            if(ratings[i] > ratings[i-1])
                candy[i] = candy[i-1] + 1;
        }
        
        for(int i=n-2;i>=0;i--){
            if(ratings[i] > ratings[i+1]){
                candy[i] = max(candy[i+1] + 1, candy[i]);
            }
        }
        int res = 0;
        for(int a: candy)
            res += a;
        return res;
    }
};
```

