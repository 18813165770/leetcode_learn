## 贪心算法简单题

##### 455 分发饼干

##### 376 摆动序列

### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但ZJ是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```
示例 1:输入: g = [1,2,3], s = [1,1]  输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

示例 2:输入: g = [1,2], s = [1,2,3] 输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```


提示：

* 1 <= g.length <= 3 * 104
* 0 <= s.length <= 3 * 104
* 1 <= g[i], s[j] <= 231 - 1

**题意分析**

贪心算法的思路是在局部最优的情况下，可以通过局部最优达到全局最优。

本题是说为了满足更多的小孩，就不能造成饼干尺寸的浪费。大尺寸的饼干既可以满足大胃口的小孩，也可以满足小胃口的小孩，那么就应该优先满足大胃口的小孩。“局部最优”就是大饼干满足大胃口，“全局最优”就是尽可能喂饱更多的小孩。

**排序+贪心**

通过贪心策略，先对饼干和小孩数组做排序，然后从后往前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足的小孩的数量。

```c++
//时间复杂度O(logn)，空间复杂度O(1)
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());  
        sort(s.begin(), s.end());
        int index = s.size()-1;  //饼干的最大下标
        int result = 0;
        for(int i = g.size()-1; i >= 0; i--){
            if(index >= 0 && s[index] >= g[i]){
                result++;
                index--;
            }
        }
        return result;
    }
};
```

换一种思路，饼干能满足大胃口的孩子，那必然可以满足小胃口的孩子，同样是满足一个孩子，满足小胃口的孩子却不一定能满足大胃口的孩子。

所以先对饼干和小孩数组做排序，然后从小往大遍历饼干，如果小饼干满足不了小胃口的孩子那么肯定也满足不了大胃口的孩子，舍弃。如果满足了，那么就跳到下一个孩子，最后饼干都发完了，那么对满足几个孩子做统计。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());  
        sort(s.begin(), s.end());
        int index = 0;
        for(int i = 0; i < s.size(); i++){
            if(index < g.size() && s[i] >= g[index]){
                index++;
            }
        }
        return index;
    }
};
```

### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度：中等

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```
示例 1：输入：nums = [1,7,4,9,2,5]  输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：输入：nums = [1,17,5,10,13,15,10,5,16,8]  输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：输入：nums = [1,2,3,4,5,6,7,8,9]  输出：2
```


提示：

* 1 <= nums.length <= 1000
* 0 <= nums[i] <= 1000

**题意解析**

看到本题中求摆动序列的最长子序列的长度，首先想到的是动态规划的思路。

**动态规划**

本题中的一个思路是**首先预处理，然后去掉连续的重复数字**，

1.确定dp数组及下标含义：dp[i]表示从[0,i]的最长子序列

2.递归数组：如果是一正一负，则dp[i] = dp[i-1]+1, 否则也不需要去删除原数组中的值，直接dp[i] = dp[i-1]。

```c++
if((nums[i]*nums[i-1]) * (nums[i-1]*nums[i-2]) < 0)
	dp[i] = dp[i - 1] + 1;
else:
	dp[i] = dp[i-1];
```

3.初始化

从递推公式可以看出需要提前给出dp[0], dp[1]。然后for循环从2开始。dp[0]表示一个元素，则dp[0] = 1，如果提前**去重**过了，那么无论nums[1]是比nums[0]大还是小都可以，dp[1] = 2;

4.遍历顺序：从递推公式可以看出，遍历顺序是从前往后

5.举例推导：

输入：nums = [1,7,4,9,2,5]  输出：6

去重nums2 = [1,7,4,9,2,5] ，dp数组：

| 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |

返回dp[nums.size()-1]则是最终值。

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return 0;

        vector<int> newnums;
        newnums.push_back(nums[0]);
        for(int i=1;i<n;i++){
            if(nums[i] != nums[i-1])
                newnums.push_back(nums[i]);  //去掉重复的数字
        }

        int n2 = newnums.size();
        if(n2 <= 2) 
            return n2;
        vector<int> dp(n2, 0);
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2; i < n2; i++){
            if((newnums[i] - newnums[i-1])*(newnums[i-1]-newnums[i-2]) < 0)
                dp[i] = dp[i-1]+1;
            else
                dp[i] = dp[i-1];
        }
        return dp[n2-1];

    }
};
```

**贪心算法**

建立两个数组，使用up数组来确定递增的最长摆动序列长度，down数组来确定递减的最长摆动序列长度。只有一个数字时默认是1.

1. nums[i+1] > nums[i]：假设down[i]表示最长摆动序列的最远末尾元素下标i，那么遇到上升元素之后，up[i+1]=down[i]+1，这是因为up一定是在down之后的。

2. nums[i+1] < nums[i]：假设up[i]表示最长摆动序列的最远末尾元素下标i，那么遇到下降元素之后，down[i+1]=up[i]+1，这是因为down一定是在up之后的。

3. nums[i+1]=nums[i]：相同的元素则说明不上不下，不能用于任何序列，保持不变。

   举例：nums = [1,7,4,9,2,5]，演示如下：

   | i    | 0    | 1        | 2        | 3          | 4            | 5              |
   | ---- | ---- | -------- | -------- | ---------- | ------------ | -------------- |
   | nums | 1    | 7        | 4        | 9          | 2            | 5              |
   | up   | 1(1) | 2（1,7） | 2（1,7） | 4(1,7,4,9) | 4(1,7,4,9)   | 6(1,7,4,9,2,5) |
   |      | /    | \        | /        | \          | /            |                |
   | down | 1(1) | 1(1)     | 3(1,7,4) | 3(1,7,4)   | 5(1,7,4,9,2) | 5(1,7,4,9,2)   |

   ```C++
   class Solution {
   public:
       int wiggleMaxLength(vector<int>& nums) {
           int down = 1, up = 1;
           for(int i = 1; i < nums.size(); i++){
               if(nums[i] > nums[i-1])
                   up = down + 1;
               else if(nums[i] < nums[i-1])
                   down = up + 1;
           }    
           return nums.size() == 0 ? 0 : max(down, up);
       }
   };
   ```

   

