## 贪心算法简单题

##### 455 分发饼干

##### 376 摆动序列

### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但ZJ是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```
示例 1:输入: g = [1,2,3], s = [1,1]  输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

示例 2:输入: g = [1,2], s = [1,2,3] 输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```


提示：

* 1 <= g.length <= 3 * 104
* 0 <= s.length <= 3 * 104
* 1 <= g[i], s[j] <= 231 - 1

**题意分析**

贪心算法的思路是在局部最优的情况下，可以通过局部最优达到全局最优。

本题是说为了满足更多的小孩，就不能造成饼干尺寸的浪费。大尺寸的饼干既可以满足大胃口的小孩，也可以满足小胃口的小孩，那么就应该优先满足大胃口的小孩。“局部最优”就是大饼干满足大胃口，“全局最优”就是尽可能喂饱更多的小孩。

**排序+贪心**

通过贪心策略，先对饼干和小孩数组做排序，然后从后往前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足的小孩的数量。

```c++
//时间复杂度O(logn)，空间复杂度O(1)
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());  
        sort(s.begin(), s.end());
        int index = s.size()-1;  //饼干的最大下标
        int result = 0;
        for(int i = g.size()-1; i >= 0; i--){
            if(index >= 0 && s[index] >= g[i]){
                result++;
                index--;
            }
        }
        return result;
    }
};
```

换一种思路，饼干能满足大胃口的孩子，那必然可以满足小胃口的孩子，同样是满足一个孩子，满足小胃口的孩子却不一定能满足大胃口的孩子。

所以先对饼干和小孩数组做排序，然后从小往大遍历饼干，如果小饼干满足不了小胃口的孩子那么肯定也满足不了大胃口的孩子，舍弃。如果满足了，那么就跳到下一个孩子，最后饼干都发完了，那么对满足几个孩子做统计。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());  
        sort(s.begin(), s.end());
        int index = 0;
        for(int i = 0; i < s.size(); i++){
            if(index < g.size() && s[i] >= g[index]){
                index++;
            }
        }
        return index;
    }
};
```

### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度：中等

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```
示例 1：输入：nums = [1,7,4,9,2,5]  输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：输入：nums = [1,17,5,10,13,15,10,5,16,8]  输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：输入：nums = [1,2,3,4,5,6,7,8,9]  输出：2
```


提示：

* 1 <= nums.length <= 1000
* 0 <= nums[i] <= 1000

**题意解析**

看到本题中求摆动序列的最长子序列的长度，首先想到的是动态规划的思路。

**动态规划**

本题中的一个思路是**首先预处理，然后去掉连续的重复数字**，

1.确定dp数组及下标含义：dp[i]表示从[0,i]的最长子序列

2.递归数组：如果是一正一负，则dp[i] = dp[i-1]+1, 否则也不需要去删除原数组中的值，直接dp[i] = dp[i-1]。

```c++
if((nums[i]*nums[i-1]) * (nums[i-1]*nums[i-2]) < 0)
	dp[i] = dp[i - 1] + 1;
else:
	dp[i] = dp[i-1];
```

3.初始化

从递推公式可以看出需要提前给出dp[0], dp[1]。然后for循环从2开始。dp[0]表示一个元素，则dp[0] = 1，如果提前**去重**过了，那么无论nums[1]是比nums[0]大还是小都可以，dp[1] = 2;

4.遍历顺序：从递推公式可以看出，遍历顺序是从前往后

5.举例推导：

输入：nums = [1,7,4,9,2,5]  输出：6

去重nums2 = [1,7,4,9,2,5] ，dp数组：

| 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |

返回dp[nums.size()-1]则是最终值。

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return 0;

        vector<int> newnums;
        newnums.push_back(nums[0]);
        for(int i=1;i<n;i++){
            if(nums[i] != nums[i-1])
                newnums.push_back(nums[i]);  //去掉重复的数字
        }

        int n2 = newnums.size();
        if(n2 <= 2) 
            return n2;
        vector<int> dp(n2, 0);
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2; i < n2; i++){
            if((newnums[i] - newnums[i-1])*(newnums[i-1]-newnums[i-2]) < 0)
                dp[i] = dp[i-1]+1;
            else
                dp[i] = dp[i-1];
        }
        return dp[n2-1];

    }
};
```

**贪心算法**

建立两个数组，使用up数组来确定递增的最长摆动序列长度，down数组来确定递减的最长摆动序列长度。只有一个数字时默认是1.

1. nums[i+1] > nums[i]：假设down[i]表示最长摆动序列的最远末尾元素下标i，那么遇到上升元素之后，up[i+1]=down[i]+1，这是因为up一定是在down之后的。

2. nums[i+1] < nums[i]：假设up[i]表示最长摆动序列的最远末尾元素下标i，那么遇到下降元素之后，down[i+1]=up[i]+1，这是因为down一定是在up之后的。

3. nums[i+1]=nums[i]：相同的元素则说明不上不下，不能用于任何序列，保持不变。

   举例：nums = [1,7,4,9,2,5]，演示如下：

   | i    | 0    | 1        | 2        | 3          | 4            | 5              |
   | ---- | ---- | -------- | -------- | ---------- | ------------ | -------------- |
   | nums | 1    | 7        | 4        | 9          | 2            | 5              |
   | up   | 1(1) | 2（1,7） | 2（1,7） | 4(1,7,4,9) | 4(1,7,4,9)   | 6(1,7,4,9,2,5) |
   |      | /    | \        | /        | \          | /            |                |
   | down | 1(1) | 1(1)     | 3(1,7,4) | 3(1,7,4)   | 5(1,7,4,9,2) | 5(1,7,4,9,2)   |

   ```C++
   class Solution {
   public:
       int wiggleMaxLength(vector<int>& nums) {
           int down = 1, up = 1;
           for(int i = 1; i < nums.size(); i++){
               if(nums[i] > nums[i-1])
                   up = down + 1;
               else if(nums[i] < nums[i-1])
                   down = up + 1;
           }    
           return nums.size() == 0 ? 0 : max(down, up);
       }
   };
   ```

   ### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

```
示例 1：输入：nums = [2,3,1,1,4]  输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：输入：nums = [3,2,1,0,4]  输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```


提示：

* 1 <= nums.length <= 3 * 1041
* 0 <= nums[i] <= 105

**题意解析**

**贪心算法**

本题的意思是说，想象你是在跳格子，格子里的数代表可以跳几次，只要格子的值不等于0，则肯定可以跳到最后。每次走到一个格子，检查你手上有的格子数量，和你当前所站在的格子数量那个大，就选择那个。而这个也是贪心的局部最优，每次选择可以跳的最大值，全局最优就是可以跳到最后。

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size()==0)
            return true;
        int cur=nums[0];  //i=0
        int i = 1;
        for(;cur != 0 && i<nums.size();i++){
            cur--;
            if(cur < nums[i])
                cur=nums[i];
        }
        return i == nums.size(); 
    }
};
```

**动态规划**

使用动态规划来分析：

1.确定dp数组及下标含义：dp[i]用来表示到下标i处，可以跳跃的最大长度dp[i]

2.递推函数：dp[i]取决于前一个dp[i-1]，如果前一个dp[i-1]跳到当前位置后剩余的跳跃数dp[i-1]-1,和当前位置的跳跃数nums[i]，取最大值就是可以跳跃的最大长度。当然本处有个条件就是dp[i-1]不能是0，如果是0，则无法跳到当前位置。

3.初始化dp[0] =  nums[0];

4.遍历顺序：从递推函数可以知道只取决于前一个dp位置，因此是从前往后遍历

5.举例推导：nums = [2,3,1,1,4] ， dp=[2,3,2,1,4]，如果顺利遍历完则说明可以跳到最后位置，返回true，如果中间有一个dp[i-1]等于0，则返回false。

动态规划代码：

```C++
//时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 0) return true;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        for(int i=1;i<nums.size();i++){
            if(dp[i-1] == 0)
                return false;
            dp[i] = max(nums[i], dp[i-1] - 1);
        }
        return true;
    }
};
```

优化代码：由于dp[i]只取决于dp[i-1]，因此可以使用滚动数组，只设置两个变量

```c++
//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 0) return true;
        vector<int> dp(2);
        dp[0] = nums[0];
        for(int i=1;i<nums.size();i++){
            if(dp[0] == 0)
                return false;
            dp[1] = max(nums[i], dp[0] - 1);
            dp[0] = dp[1];
        }
        return true;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

```
示例 1:输入: nums = [2,3,1,1,4]  输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:输入: nums = [2,3,0,1,4]  输出: 2
```


提示:

* 1 <= nums.length <= 104
* 0 <= nums[i] <= 1000

**题意解析**

本题是给定非负整数数组 nums，假设你总是可以到达数组的最后一个位置，问达到最后一个位置的最少的跳跃次数。本题和上一题的区别在于：一定可以达到最后位置，问最少跳跃次数。

**使用动态规划来分析**：

题目中给出**一定可以达到最后位置**，那么我们可以从末尾往前开始求最少的步数。新建一个dp数组，长度和nums数组等长，如果从末尾开始，俺么我们知道在最后一个位置的元素dp[nums.size()-1]的最少跳跃数是0，因为它就在最后一个位置。

1.dp数组及下标含义：dp[i]表示下标i达到最后位置所用的最少跳跃次数是dp[i]。

2.递推公式：在下标i处，如果下标i的位置的数nums[i] == j，则说明在nums[i]可以跳跃到的范围是[i+1,i+2,...i+j]，那么dp[i] = min(dp[i+1],dp[i+2]...dp[i+j]) + 1。

3.初始化dp[nums.size()-1] = 0;

4.遍历顺序从后往前的

5.举例

对于[2,3,0,1,4]：对应的dp数组[?,?,?,?,0]

从倒数第二位，对应的nums=1, 范围是走1步，因此dp[3] = 1;

从倒数第三位，对应的nums=0，表示不走，对应的dp[2]我们取个不影响结果的值dp[2]=*;

从倒数第四位，对应的nums=3, 范围是走3步，意思就是在下标[2,3,4]的范围内都可以走，那么dp[1] = min(dp[2], dp[3], dp[4]) + 1 =  1

到第一个位置，对应的nums=2,范围是走2步，对应的dp[0] = min(dp[1], dp[2]) + 1 = 2

**动规代码如下：**

```c++
class Solution {
    public int jump(int[] nums) {
        vector<int> dp(nums.size());
        for(int i=nums.size()-2;i>=0;i--)
            if(nums[i] == 0){  //如果有元素是0，则本身的跳跃式就是0，就走不到终点，设置一个最大值，
                dp[i] = INT_MAX;
                continue；
            }
        	minL = INT_MAX;
        	for(j = 1; j <= nums[i] && i+j < nums.length(); j++){
                minL = min(minL, dp[i+j]);
            }   //找到(i+1,i+2,...,i+j)范围内的dp最小值
        	if(minL == INT_MAX){
                dp[i] = minL;
                continue;
            }
        	dp[i] = min+1;
    	} 
    	return dp[0];
    }
}
```

### [1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

```
示例 1：输入：A = [4,2,3], K = 1  输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
示例 2：输入：A = [3,-1,0,2], K = 3  输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：输入：A = [2,-3,-1,5,-4], K = 2  输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
```


提示：

* 1 <= A.length <= 10000
* 1 <= K <= 10000
* -100 <= A[i] <= 100

**题意解析**

本题是给一个整数数组，可以将其中的k个元素A[i]变成-A[i]，使得最终数组和最大。

贪心的局部最优：让绝对值大的负数转成整数，数值最大，全局最优：整个数组和最大

如果负数都转成整数了，k>0，则此时是一个全正数的序列，只有让最小的值转负数，才能保持整个数组和最大。

具体的解题思路：

1.将整个数组按照**绝对值从大到小**排序

2.从前往后遍历，对负数的值取反，并且k--

3.如果k依然大于0，则反复将最后一个数（最小的数）不断取反。

4.全部数组值加和

```C++
class Solution {
public:
    static bool cmp(int a, int b){
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp); //1.将整个数组按照**绝对值从大到小**排序
        for(int i = 0; i < nums.size() && k > 0; i++){ //2.从前往后遍历，对负数的值取反，并且k--
            if(nums[i] < 0)
            {
                nums[i] *= -1;
                k--;
            }
        }
        if(k % 2 == 1) //3.如果k依然大于0，则反复将最后一个数（最小的数）不断取反。
            nums[nums.size() - 1] *= -1;

        int result = 0;  //4.全部数组值加和
        for(int num : nums)
            result += num;
        return result;
    }
};
```

#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

头条考过，难度：中等

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。

```
示例 1:输入: gas  = [1,2,3,4,5]  cost = [3,4,5,1,2]  输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

示例 2:输入: gas  = [2,3,4]  cost = [3,4,3]  输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

**题意解析**

**图像解法**

题目的意思：环上有N个加油站，每到一个站点i，可以加gas[i]的汽油，离开站点i需要cost[i]的汽油。问从那个节点开始走，可以绕一圈回到原位。

如果我们把站点加的油和离开消耗的油看作整体，将`sum = gas[i] - cost[i]`作为站点i的油量变化值。如果可以绕一圈回来，则肯定说明sum的累加和一直都是>0的。

我们把每个节点的油量变化值在坐标轴上显示出来。假设sum的变化是：

| sum  | 2    | 3    | -2   | -3   | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

如果我们把第一个点作为起点肯定不行，因为在过程中sum有变成<0，因此我们需要找一个起始位置start，使得从起始位置开始累加和一直都是大于等于0。

那么我们能找那个点呢？最低点。如果我们把sum中的最低点作为起始点，也就相当于把这个点作为坐标原点，相当于把整个图像向上平移。再加上整个数组是环形数组，则sum的取值变化是

| sum  | 5    | 6    | 1    | 0    | 5    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

另外：如果总油量`sum(gas[...]) < sum(cost[...])`，总油量小于总消耗量，则肯定无法到达起始位置的。

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size(); 
        int start = 0;  //一开始假设起始位置从0开始
        int sum = 0;
        int minSum = INT_MAX;  //统计最小的num，来找到起始位置
        for(int i = 0; i < n; i++){
            sum += (gas[i] - cost[i]);
            if(sum < minSum){
                minSum = sum;  //// 经过第 i 个站点后，使 sum 到达新低 所以站点 i + 1 就是最低点（起点）
                start = i + 1;
            }
        }
        
        if(sum < 0)  //总油量小于总消耗量
            return -1;  
        return start == n ? 0 : start;
    }
};
```

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

难度：困难

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

```
示例 1：输入：[1,0,2] 输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2：输入：[1,2,2]输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

**题意解析**

给一个评分数组，对每个孩子分发糖果，保证每个孩子最少1个糖果，如果孩子i的左边或者右边的打分比它高，需要多发最少一个糖果。问最少需要准备多少颗糖果。

这个题需要考虑每个孩子的左边和右边两种情况，只要rating[i] < rating[i-1]，或者rating[i] < rating[i+1]，则左右两边最少可以得到的糖果数就是：candy[i-1] = candy[i]+1，或者candy[i+1]=candy[i]+1。

本题我们针对从左到右和从右到左分两种情况分别讨论：

从左到右情况（只判断右孩子>左孩子）：rating[0]初始化为1，i从1遍历，如果rating[i] > rating[i-1]， candy[i]=candy[i-1]+1。

从右到左情况（只判断左孩子>右孩子）：由于从左到右我们已经得出一个candy[n-1]的值，那么i遍历从n-2开始，如果rating[i] > rating[i+1]，此时candy[i]其实有两个选择：一个选择是candy[i+1]+1，另一个选择是从左到右遍历的candy[i]。此时为了保证贪心，每个孩子获得的糖果既要大于左边也要大于右边，则取最大值。

`max(candy[i+1]+1, candy[i])`

C++代码如下：

```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> candy(n, 1);

        for(int i=1;i<n;i++){
            if(ratings[i] > ratings[i-1])
                candy[i] = candy[i-1] + 1;
        }
        
        for(int i=n-2;i>=0;i--){
            if(ratings[i] > ratings[i+1]){
                candy[i] = max(candy[i+1] + 1, candy[i]);
            }
        }
        int res = 0;
        for(int a: candy)
            res += a;
        return res;
    }
};
```

### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

难度：中等

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

```
示例 1：输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

示例 2：输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```


提示：

* 1 <= people.length <= 2000
* 0 <= hi <= 106
* 0 <= ki < people.length
* 题目数据确保队列可以被重建

**题意解析**

本题中有两个维度，一个身高h，一个排列在前面的人k。在前一个题“分发糖果”中也考虑了两个维度。所以方法就是先确定一个维度再考虑另一个维度。

那么先确定那个维度？

如果先确定k，按照k从大到小排序[[4,4],[5,2],[7,1],[6,1],[7,0],[5,0]]，发现k的排列不符合要求，h也无好的排列方法。如果先确定h，将h从大到小排序（身高相同k小排列在前面），那么就可以先确定一个维度“身高”，然后我们再按照k为下标插入到队列中。举例：

```
比如：[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]

按照身高排序：[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]

再按照k的大小插入队列：

插入[7,0]，k=0,插入0的位置[[7,0]]

插入[7,1]，k=1,插入1的位置[[7,0],[7,1]]

插入[6,1]，k=1,插入1的位置[[7,0],[6,1],[7,1]]

插入[5,0]，k=0,插入0的位置[[5,0],[7,0],[6,1],[7,1]]

插入[5,2]，k=2,插入2的位置[[5,0],[7,0],[5,2],[6,1],[7,1]]

插入[4,4]，k=4,插入4的位置[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

C++代码如下：

```c++
class Solution {
public:
    bool static cmp(vector<int> a, vector<int> b){
        if(a[0] == b[0]) return a[1] < b[1];
        else
            return a[0] > b[0];
    }

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);  //按照身高从大到小排序,相同身高的k小的排序前面
        vector<vector<int>> result;  //建立一个队列
        for(int i = 0; i < people.size(); i++){
            int position = people[i][1];
            result.insert(result.begin() + position, people[i]);
        }
        return result;
    }
};
```

**时间复杂度O(nlogn + n^2)。空间复杂度O(n)**。排序nlogn。插入元素n^2。vector是c++里的动态数组(底层是普通数组)，vector有两个维度：一个是size，一个是capicity。如果插入元素的位置超过普通数组的长度，vector底部capicity会扩容，则会申请普通数组长度的2倍的空间，然后把数组拷贝到更大的数组上，释放原来的数组大小。如果多次扩充，则多次拷贝，时间复杂度会上升。执行时间：200ms。

比如：vector<int> {1,2,3}，此时size=3，capicity=3，如果插入元素4，则size=4，capicity=6

优化版本：将vector改为list。list底部是链表

```C++
class Solution {
public:
    static bool cmp(vector<int> a, vector<int> b){
        if(a[0] == b[0]) return a[1] < b[1];
        else
            return a[0] > b[0];
    }

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);  //按照身高从大到小排序,相同身高的k小的排序前面
        list<vector<int>> que;  //建立一个list,list底层是链表实现
        for(int i = 0; i < people.size(); i++){
            int position = people[i][1];
            std::list<vector<int>>::iterator quebegin = que.begin();  //将链表的头部元素赋值到指针上
            while(position--){   //几个位置，则指针后移动几位
                quebegin++;
            }
            que.insert(quebegin, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());  //把链表转成vector返回
    }
};
```

**时间复杂度O(nlogn + n^2)。空间复杂度O(n)**。list的底层是链表，通过对list的首元素赋值指针，指针移动再插入元素。执行时间：88ms。

#### [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

难度：简单

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

```
示例 1：输入：bills = [5,5,5,10,20]  输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

示例 2：输入：bills = [5,5,10,10,20]  输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。

示例 3：输入：bills = [5,5,10] 输出：true
示例 4：输入：bills = [10,10]  输出：false
```


提示：

* 1 <= bills.length <= 105
* bills[i] 不是 5 就是 10 或是 20 

题意解析

本题是说顾客会提供的金额只有三种情况：5，10，20。柠檬水是5美元。问能否对所有顾客都找零。

分析情况如下：

情况1.如果是5美元，则收下。

情况2.如果是10美元，则消耗5美元，收下10美元。如果没有5没有，返回false。

情况3.如果是20美元，则有两种情况：1.消耗一个10美元和一个5美元，2.消耗3个5美元。如果没有这两种情况，返回false。

这里情况1和情况2都是固定的，情况3是有一个优先选择的，就是优先消耗10美元+5美元。为什么呢？因为10美元只能用来找零20美元，但是5美元可以用来找零10美元和20美元。所以这里的局部最优就是优先使用10美元，全局最优就是保证所有顾客都能找零。

```C++
//执行时间100ms,时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five=0, ten=0, twenty=0;
        for(int bill : bills){
            if(bill == 5){  //情况1
                five++;
            }else if(bill == 10){  //情况2
                if(five <= 0) return false;
                five--;
                ten++;
            }else if(bill == 20){  //情况3
                if(ten > 0 and five > 0){
                    ten--;
                    five--;
                    twenty++;
                }else if(five >= 3){
                    five -= 3;
                }else{
                    return false;
                }
            }
        }
        return true;
    }
};
```

### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

难度：中等

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

```
示例 1：输入：points = [[10,16],[2,8],[1,6],[7,12]]  输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
示例 2：输入：points = [[1,2],[3,4],[5,6],[7,8]]     输出：4
示例 3：输入：points = [[1,2],[2,3],[3,4],[4,5]]     输出：2
示例 4：输入：points = [[1,2]]                       输出：1
示例 5：输入：points = [[2,3],[2,3]]                 输出：1
```


提示：

* 1 <= points.length <= 104
* points[i].length == 2
* -231 <= xstart < xend <= 231 - 1

**题意解析**

题目给定气球的开始位置和结束位置， 如果弓箭xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制，问射出的最小弓箭数。如果要求最少弓箭数，则气球尽可能有重叠，因此对于气球是二维的，我们根据起始位置排序，则就可以知道是否有重叠。

1.根据气球的起始位置排序

2.最少弓箭数是1，如果两个气球(i, j)，i的结束位置<j的起始位置，则肯定不重叠，则弓箭数+1；如果i的结束位置>=j的起始位置，则重叠了，更新气球的终点位置的最小边界，弓箭数保持不变。

```C++
//时间复杂度O(nlogn)， 空间复杂度O(1)
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b){
        return a[0] < b[0];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);

        int result = 1; //points不是空，则最少弓箭数赋值为1
        for(int i = 1; i < points.size(); i++){
            if(points[i][0] > points[i-1][1]){  //两个气球不重叠  这里是>，不是>=
                result++;
            }else{
                points[i][1] = min(points[i][1], points[i - 1][1]);  //重叠气球的最小边界
            }
        }
        return result;
    }
};
```

