#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

难度 简单

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```
示例 1：输入：[7,1,5,3,6,4]   输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：输入：prices = [7,6,4,3,1]  输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

题意解析：

**暴力解法：**

买卖股票，从第i个点买入，得从第i+1之后的点卖出，找出卖出的最大利润。

```c++
//执行结果：超出时间限制  时间复杂度O(n^2),空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        int res = 0;
        for(int i = 0; i < prices.size()-1; i++){
            for(int j = i + 1; j <= prices.size() - 1; j++){
                res = max(res, prices[j] - prices[i]);
            }
        }
        return res;
    }
};
```

**一次遍历**

买卖股票只买入卖出一次，因此维护一个最小值买入，最大值利润。

```c++
//执行结果：通过  时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        int low = prices[0];
        int res = 0;

        for(int i = 1; i < prices.size(); i++){
            res = max(res, prices[i] - low);
            low = min(low, prices[i]);
        }
        return res;
    }
};
```

动态规划

使用动态规划五部曲来分析：

1.确定dp数组及下标含义

从题目中可以看出股票有两个状态，使用0表示持有股票后的最多现金，1表示不持有股票后的最多现金。

`dp[i][0]`表示第i天持有股票所得到的最多现金，由于题目没有说现金，那么可以认为一开始现金是0，那么买入股票后的现金就是`-prices[i]`。

`dp[i][1]`表示第i天不持有股票所得到的最多现金。

这里“持有”不代表是买入，也可以是昨天买入，然后今天保持的状态。

2.递推公式。

如果第i天持有股票prices[i]，那么状态是什么？

* 第i-1天就持有股票，然后保持现状，那么得到的现金就是昨天持有的股票所得到的现金`dp[i-1][0]`

* 第i天买入股票，那么得到的现金就是-prices[i]。

那么`dp[i][0]`选择现金最大的就是`dp[i][0] = max(dp[i-1][0], -price[i])`

如果第i天不持有股票prices[i]，那么状态是什么？

* 第i-1天就不持有股票，然后保持现状，那么得到的现金就是昨天不持有的股票所得到的现金`dp[i-1][1]`

* 第i天卖出股票，那么得到的现金就是按照今天的股票价格卖出的现金：`price[i] + dp[i-1][0]`

那么`dp[i][1]`选择最大的就是`dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])`

3.初始化

从上面递推公式可以看出都是从`dp[0][0]`和`dp[0][1]`推导得出的。`dp[0][0]`表示第0天持有股票，那么就一定是买入股票了，所以`dp[0][0] = -prices[0]`

`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0， `dp[0][1] = 0`

4.确定遍历顺序

由于dp[i]是从dp[-1]转移过来，因此遍历从前往后

5.举例推导

输入[7,1,5,3,6,4]  

| `dp[i][0]` | -7   | -1   | -1   | -1   | -1   | -1   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| `dp[i][1]` | 0    | 0    | 4    | 4    | 5    | 5    |

最终结果就是`dp[5][0]`

**c++代码分析**

```c++
//执行结果：376ms通过  时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[len-1][1];
    }
};
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) 

难度  中等

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
示例 1:输入: prices = [7,1,5,3,6,4]  输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:输入: prices = [1,2,3,4,5]  输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

题意解析：

这道题目和121题的区别：

本题是一只股票可以买入卖出多次，但是再次买入必须在卖出之后，统计最终利润。

121题是一只股票只能买入卖出一次

**贪心算法**

如果用贪心算法来解析，最终利润可以分解的，怎么分解呢？

假如第0天买入，第三天卖出，那么利润是prices[3]-prices[0]。

相当于(prices[3]-prices[2])+(prices[2]-prices[1])+(prices[1]-prices[0])。就是把利润分解到每一天的单位里。

例如[7,1,5,3,6,4]，利润[-6,4,-2,3,-2]。总利润把正的值加起来7。**贪心只收集正的利润。正的利润区间就是股票买卖的区间**

```c++
//时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)  return 0;
        
        vector<int> profit(prices.size()-1);
        for(int i = 1; i < prices.size(); i++){
            profit[i-1] = prices[i] - prices[i-1];
        }
        int res = 0;
        for(int i = 0; i < profit.size(); i++){
            if(profit[i] > 0) res+=profit[i];
        }
        return res;
    }
};
//以上可以做一下优化，不使用vector.//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)  return 0;
        
        int res = 0;
        for(int i = 1; i < prices.size(); i++){
            res += max(prices[i] - prices[i-1], 0);
        }
        return res;
    }
};
```

**动态规划**

1.确定dp数组及下标含义

dp数组每个位置设置两个，0表示持有该股票，1表示不持有该股票。

dp[i]表示在第i个股票持有和不持有的最大收益是dp[i]。

2.确定递推公式

如果第i天持有该股票，有两种情况，选择最大的持有

* 在第i-1天就持有，所以在第i天继续持有。则`dp[i][0] = dp[i-1][0]`

* 在第i天买入，则在第i天持有，则`dp[i][0] = dp[i-1][1] - prices[i]`

如果在第i天不持有该股票，有两种情况，选择最大的卖出

* 在第i-1天就不持有，则第i天不持有，则`dp[i][1] = dp[i-1][1]`

* 在第i天卖出，则在第i天不持有。`dp[i][1] = dp[i-1][0]+prices[i]`

所以递推公式如下：

`dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`

`dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])`

121题全程只能买入一次，所以在第i买入的时候是当天持有股票`dp[i][0] = -prices[i]`

本题中一只股票可以买入卖出多次，因此当第i天买入股票，则所得的现金就是昨天不持有股票的现金减去当天的票价格`dp[i-1][1] - prices[i]`

3.初始化

`dp[0][0] = -prices[i]`

`dp[0][1] = 0`

4.遍历顺序

从递推公式可以看出，dp[i]就是从dp[i-1]推导出来，因此是从前往后遍历

5.举例推导

prices = [7,1,5,3,6,4]

| `dp[0][0]` | -7   | -1   | -1   | 1    | 1    | 3    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| `dp[0][1]` | 0    | 0    | 4    | 4    | 7    | 7    |

最终输出`dp[prices.size()-1][1]`

c++代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;

        vector<vector<int>> dp(prices.size(), vector<int>(2));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        } 
        return dp[prices.size()-1][1];
    }
};
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

难度 困难

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。

示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。

示例 4： 输入：prices = [1] 输出：0

提示：
1 <= prices.length <= 10^5
0 <= prices[i] <= 10^5
```

思路解析：

本题和前两道股票问题的区别在于，本题中股票交易“**最多可以完成 两笔 交易”**。意思就是可以交易一次，可以交易两次，也可以不交易。

用动态规划五部曲来分析：

1.确定dp数组及下标含义

每天的股票有5个状态。

0表示没有状态，

1表示第一次买入，

2表示第一次卖出，

3表示第二次买入，

4表示第二次卖出。

`dp[i][j] .`第i天，状态j的股票最大现金是`dp[i][j]`

2.确定递归公式

不同状态的递归公式：

第i天状态1（第一次买入）的情况`dp[i][1]`有2种：

* 第i-1天买入，第i天保持现状，则`dp[i][1] = dp[i-1][1]`

* 第i天是第一次买入，则`dp[i][1] = dp[i-1][0]-prices[i]`

`dp[i][1]` 取两种情况的最大值`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`

第i天状态2（第一次卖出）的情况`dp[i][2]`有2种：

* 第i-1天就卖出了，然后第i天保持现状，因此`dp[i][2] = dp[i-1][2]`

* 第i天第一次卖出，则`dp[i][2] = dp[i-1][1] + prices[i]`

`dp[i][2]` 取两种情况的最大值`dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])`

第i天状态3（第二次买入）的情况`dp[i][3]`有2种：

* 第i-1天买入，第i天保持现状，则`dp[i][3] = dp[i-1][3]`

* 第i天是第二次买入，则`dp[i][3] = dp[i-1][2]-prices[i]`

`dp[i][3]` 取两种情况的最大值`dp[i][3] = max(dp[i][3] = dp[i-1][2],dp[i-1][2]-prices[i] `

第i天状态4（第二次卖出）的情况`dp[i][4]`有2种：

* 第i-1天就卖出了，然后第i天保持现状，因此`dp[i][4] = dp[i-1][4]`

* 第i天第二次卖出，则`dp[i][2] = dp[i-1][3] + prices[i]`

`dp[i][4]` 取两种情况的最大值`dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])`

3.dp数组初始化

第0天没有操作，则`dp[0][0] = 0;`

第0天第一次买入，则`dp[0][1] = -prices[0];`

第0天第一次卖出，首先卖出的操作肯定是能获取利润，如果利润比0小肯定就没有必要要这个收益了，因此初始化为0。`dp[0][2] = 0;`

第0天第二次买入，依赖第一次买入，第一次卖出。只要买入现金就会变少，因此`dp[0][3] = -prices[0]`

第0天第二次卖出，`dp[0][4] = 0`

4.确定遍历顺序

由于dp[i]取决于dp[i-1]，因此是从前往后遍历。

5.举例推导

以输入[1,2,3,4,5]为例

`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`

`dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])`

`dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i]`

`dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])`

| 输入                   | 1    | 2    | 3    | 4    | 5    |
| ---------------------- | ---- | ---- | ---- | ---- | ---- |
| `dp[0][0] 无状态`      | 0    | 0    | 0    | 0    | 0    |
| `dp[0][1]` 第一次买入  | -1   | -1   | -1   | -1   | -1   |
| `dp[0][2]` 第一次卖出  | 0    | 1    | 2    | 3    | 4    |
| `dp[0][3]`  第二次买入 | -1   | -1   | -1   | -1   | -1   |
| `dp[0][4]` 第二次卖出  | 0    | 1    | 2    | 3    | 4    |

利润最大的时候一定是卖出的时候，两次卖出的 最大利润就是`dp[4][4]`

c++代码如下：

```c++
//时间复杂度O(n),空间复杂度O(n * 5)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        //1.确定dp数组及下标含义：`dp[i][j] .`第i天，状态j的股票最大现金是`dp[i][j]`  五个状态
        vector<vector<int>> dp(prices.size(), vector<int>(5));

        //2.初始化 0表示没有状态，1表示第一次买入，2表示第一次卖出，3表示第二次买入，4表示第二次卖出。
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[prices.size()-1][4];
    }
};
```

空间优化

```c++
//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        //1.确定dp数组及下标含义：`dp[i][j] .`第i天，状态j的股票最大现金是`dp[i][j]`  五个状态
        vector<int> dp(5);

        //2.初始化 0表示没有状态，1表示第一次买入，2表示第一次卖出，3表示第二次买入，4表示第二次卖出。
        dp[0] = 0;
        dp[1] = -prices[0];
        dp[2] = 0;
        dp[3] = -prices[0];
        dp[4] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
	}
};
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。

示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

提示：

- 0 <= k <= 100
- 0 <= prices.length <= 1000
- 0 <= prices[i] <= 1000

**题意解析**

本题和123题的区别：

123题是股票最多交易2次，即可以交易一次，可以交易两次，也可以不交易。

本题是股票最多交易k次，该k由题目指定。那就是说可以不交易，交易1次， 交易2次...交易k次

顺着上一题的动规五部曲来分析

1.确定dp数组及下标含义。

股票的状态分以下：0表示无状态，1表示第一次买入，2表示第一次卖出，3表示第二次买入，4表示第二次卖出...依次类推，

可以发现一个规律就是**奇数时买入，偶数时卖出**。股票一共交易k次即k次买入k次卖出，加上无状态，那么状态一共有**（2 * k + 1）**

```c++
vector<vector<int>> dp(prices.size(), vector<int>(2*k+1));
```

我们使用`dp[i][j]`表示在第i支股票，状态j下用户所能得到的最大现金。

2.递推公式

`dp[i][1]`(第一次买入)的递推情况有两种：

* 第i-1次就买入，在第i次只是维持状态，`dp[i][1] = dp[i-1][1]`

* 第i次是第一次买入，首次用户的现金是0，那么第一次买入就是`dp[i][1] = dp[i-1][0]- prices[i] `

那么`dp[i][1]`就是取最大的现金`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`

`dp[i][2]`（第一次卖出）的递推情况有两种：

* 第i-1次就卖出，在第i次维持状态，`dp[i][2] = dp[i-1][2]`
* 第i次是第一次卖出，那么表名前i-1天没有卖出，那么得到的现金就是`dp[i][2] = dp[i-1][1] + prices[i]`

那么`dp[i][2]`就是取最大的现金`dp[i][2] = max(dp[i-1][2], dp[i-1][1]+prices[i])`

同理推出第二次买入第二次卖出的情况。可以从推理中发现：

第*次买入的递推公式：`dp[i][2*k-1] = max(dp[i-1][2*K-1], dp[i-1][2*k-2] - prices[i])`

第*次卖出的递推公式：`dp[i][2*k] = max(dp[i-1][2*k], dp[i-1][2*k-1] + prices[i])`
因此递推公式汇总：

```c++
dp[i][2*k-1] = max(dp[i-1][2*K-1], dp[i-1][2*k-2] - prices[i])
dp[i][2*k] = max(dp[i-1][2*k], dp[i-1][2*k-1] + prices[i])
```

3.初始化

无状态就是无现金，初始化`dp[0][0] = 0`;

第一次买入，由于一开始无现金，那么第一次买入肯定就是负的`dp[0][1] = -prices[0]`

第一次卖出，那么肯定是有利润才卖出，如果卖出后利润比0小，那么就不要，因此`dp[0][2] = 0`

同理类推......，可以发现`dp[0][2*k-1] = -prices[0], dp[0][2k] = 0`

因此初始化有三种：

```c++
dp[0][0] = 0;
for(int i=1;i<=k;i++){
	dp[0][2 * i - 1] = -prices[0];
	dp[0][2 * i] = 0;
}
```

4.确定遍历顺序

由于`dp[i][2*k]`是由`dp[i][2*k-1]`推导出来的，因此是从前往后遍历。

5.举例推导：

输入：k = 2, prices = [3,2,6,5,0,3] 输出：7

|             | 3    | 2    | 6    | 5    | 0    | 3    |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0无状态     | 0    |      |      |      |      |      |
| 1第一次买入 | -3   | -2   | -2   | -2   | 0    | 0    |
| 2第一次买出 | 0    | -1   | 4    | 4    | 4    | 4    |
| 3第二次买入 | -3   | -2   | -2   | -1   | 4    | 7    |
| 4第二次买出 | 0    | 0    | 4    | 4    | 4    | 7    |

可以看到`dp[prices.size()-1]`第二次卖出得到的现金是最多的。

c++代码如下：

```c++
//时间复杂度O(n*k),空间复杂度O(n*2*k))
class Solution {
public:
	int maxProfit(int k, vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1));

        dp[0][0] = 0;
        for(int i = 1; i <= k; i++){
            dp[0][2 * i - 1] = -prices[0];
            dp[0][2 * i] = 0;
        }

        for(int i = 1; i < prices.size(); i++){
            for(int j = 1; j <= k; j++){
                dp[i][2 * j - 1] = max(dp[i - 1][2 * j - 1], dp[i - 1][2 * j - 2] - prices[i]);   //第i次买入 
                dp[i][2 * j] = max(dp[i - 1][2 * j], dp[i - 1][2 * j - 1] + prices[i]);   //第i次卖出
            }
        }

        return dp[prices.size()-1][2 * k];
    }
 };
```

也可以滚动数组，变成一维数组。一维数组得在理解了二维数组的原理前提下再更改。

```C++
class Solution {
public:
int maxProfit(int k, vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<int> dp(2 * k + 1);

        dp[0] = 0;
        for(int i = 1; i <= k; i++){
            dp[2 * i - 1] = -prices[0];
            dp[2 * i] = 0;
        }

        for(int i = 1; i < prices.size(); i++){
            for(int j = 1; j <= k; j++){
                dp[2 * j - 1] = max(dp[2 * j - 1], dp[2 * j - 2] - prices[i]);   //第i次买入 
                dp[2 * j] = max(dp[2 * j], dp[2 * j - 1] + prices[i]);   //第i次卖出
            }
        }
        return dp[2 * k];
    }
 };
```

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

难度 中等

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**题意分析**

本题相比[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) 区别在于：本题在多次买入卖出的基础上添加一个冷冻期。

使用动态规划五部曲来分析：

1.确定dp数组及下标含义

`dp[i][j]`，表示第i天的状态j下，所剩的最多现金是`dp[i][j]`

从题目来分析股票的状态：

状态一：买入股票的状态（今天买入，前一天就买入今天保持状态）

卖出股票的状态，卖出股票其实是分为两种状态的：

​	状态二：两天前卖出股票，前一天是冷冻期，今天没有操作，仍保持卖出的状态

​	状态三：今天卖出股票

状态四：冷冻期：今天冷冻期状态，该状态只能有一天。

所以j的状态分为四类：使用0，1，2，3表示。

2.确定递推公式

状态0:在第i天j=0(买入股票)的`dp[i][0]`情况：

* 前一天就买入了股票，今天仍保持该状态，`dp[i][0] = dp[i-1][0]`

* 第i天买入股票，有两种情况：
  * 前一天是冷冻期3，则`dp[i][0] = dp[i-1][3] - prices[i]`
  * 前一天是保持的卖出状态1，则`dp[i][0] = dp[i-1][1] - prices[i]`

所以买入股票状态0取最大值`dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])`

状态1:在第i天j=1(卖出股票的状态)的`dp[i][1]`情况：

* 前一天卖出股票，今天保持卖出的状态，`dp[i][1] = dp[i-1][1]`

* 前一天是冷冻期3，今天没有操作，保持卖出的状态`dp[i][1] = dp[i-1][3]`

所以卖出股票状态1取最大值`dp[i][1] = max(dp[i-1][1], dp[i-1][3])`

状态2:在第i天j=2(今天卖出股票)的`dp[i][2]`情况：

* 前一天买入股票的状态1，今天卖出`dp[i][2] = dp[i-1][0] + prices[i]`

状态3:在第i天j=3(冷冻期)的`dp[i][3]`的情况只有一种：

* 前一天是卖出的状态2，`dp[i][3] = dp[i-1][2]`

所以整体的状态汇总：

`dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1])-prices[i])`

`dp[i][1] = max(dp[i-1][1], dp[i-1][3])`

`dp[i][2] =  dp[i-1][0] + prices[i]`

`dp[i][3] = dp[i-1][2]`

3.初始化

买入状态的初始化，假设一开始用户的现金是0，买入股票后的最大现金是`dp[0][0]-prices[0]`

卖出状态的初始化，卖出是为了获取利润，如果利润比0小，那么获取就没有意义，因此初始化`dp[0][1] = 0`

今天卖出状态同理也是`dp[0][2] = 0`

冷冻期的最大现金初始化为`dp[0][3] = 0`

4.遍历顺序

由于dp[i]依赖于dp[i-1]，因此遍历顺序是从前往后的。

5.举例推导：

 输入: [1,2,3,0,2] 输出: 3

|                         | 1    | 2    | 3    | 0    | 2    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- |
| `dp[i][0] `买入状态     | -1   | -1   | -1   | 1    | 1    |
| `dp[i][1] `卖出状态     | 0    | 0    | 0    | 1    | 2    |
| `dp[i][2] `今天卖出状态 | 0    | 1    | 2    | -1   | 3    |
| `dp[i][3] `冷却状态     | 0    | 0    | 1    | 2    | -1   |

可以发现，最终交易的最大现金就是取状态一状态二状态三的最大值。如果最后一天是冷冻期，那么冷冻期也可能是最大值。

```c++
//时间复杂度O(n), 空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(4));

        dp[0][0] = -prices[0];
        dp[0][1] = dp[0][2] = dp[0][3] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][1],dp[i-1][3]) - prices[i]); //买入股票的状态
            dp[i][1] = max(dp[i-1][3], dp[i-1][1]);                                //卖出股票的状态：前一天是冷冻期，今天无操作，前一天是卖出状态，今天无操作
            dp[i][2] = dp[i-1][0] + prices[i]; //今天卖出股票
            dp[i][3] = dp[i-1][2];             //冷冻期  
        }
        return max(dp[prices.size()-1][1], max(dp[prices.size()-1][2], dp[prices.size()-1][3]));
    }
};
```

