#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

难度 简单

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```
示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

题意解析：

**暴力解法：**

买卖股票，从第i个点买入，得从第i+1之后的点卖出，找出卖出的最大利润。

```c++
//执行结果：超出时间限制  时间复杂度O(n^2),空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        int res = 0;
        for(int i = 0; i < prices.size()-1; i++){
            for(int j = i + 1; j <= prices.size() - 1; j++){
                res = max(res, prices[j] - prices[i]);
            }
        }
        return res;
    }
};
```

**一次遍历**

买卖股票只买入卖出一次，因此维护一个最小值买入，最大值利润。

```c++
//执行结果：通过  时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        int low = prices[0];
        int res = 0;

        for(int i = 1; i < prices.size(); i++){
            res = max(res, prices[i] - low);
            low = min(low, prices[i]);
        }
        return res;
    }
};
```

动态规划

使用动态规划五部曲来分析：

1.确定dp数组及下标含义

使用两个元素来表示状态，0表示持有，1表示不持有。

`dp[i][0]`表示第i天持有股票所得到的最多现金，由于题目没有说现金，那么可以认为一开始现金是0，那么买入股票后的现金就是`-prices[i]`。

`dp[i][1]`表示第i天不持有股票所得到的最多现金。

这里“持有”不代表是买入，也可以是昨天买入，然后今天保持的状态。

2.递推公式。

如果第i天持有股票prices[i]，那么状态是什么？

* 第i-1天就持有股票，然后保持现状，那么得到的现金就是昨天持有的股票所得到的现金`dp[i-1][0]`

* 第i天买入股票，那么得到的现金就是-prices[i]。

那么`dp[i][0]`选择现金最大的就是`dp[i][0] = max(dp[i-1][0], -price[i])`

如果第i天不持有股票prices[i]，那么状态是什么？

* 第i-1天就不持有股票，然后保持现状，那么得到的现金就是昨天不持有的股票所得到的现金`dp[i-1][1]`

* 第i天卖出股票，那么得到的现金就是按照今天的股票价格卖出的现金：`price[i] + dp[i-1][0]`

那么`dp[i][1]`选择最大的就是`dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])`

3.初始化

从上面递推公式可以看出都是从`dp[0][0]`和`dp[0][1]`推导得出的。`dp[0][0]`表示第0天持有股票，那么就一定是买入股票了，所以`dp[0][0] = -prices[0]`

`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0， `dp[0][1] = 0`

4.确定遍历顺序

由于dp[i]是从dp[-1]转移过来，因此遍历从前往后

5.举例推导

输入[7,1,5,3,6,4]  

| `dp[i][0]` | -7   | -1   | -1   | -1   | -1   | -1   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| `dp[i][1]` | 0    | 0    | 4    | 4    | 5    | 5    |

最终结果就是`dp[5][0]`

**c++代码分析**

```c++
//执行结果：376ms通过  时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[len-1][1];
    }
};
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) 

难度  中等

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。


```

题意解析：

这道题目和上一题的区别在于一只股票可以买入卖出多次，但是再次买入必须在卖出之后，统计最终利润。上一题是一只股票只能买入卖出一次

**贪心算法**

如果用贪心算法来解析，最终利润可以分解的，怎么分解呢？

假如第0天买入，第三天卖出，那么利润是prices[3]-prices[0]。

相当于(prices[3]-prices[2])+(prices[2]-prices[1])+(prices[1]-prices[0])。就是把利润分解到每一天的单位里。

例如[7,1,5,3,6,4]，利润[-6,4,-2,3,-2]。总利润把正的值加起来7。**贪心只收集正的利润。正的利润区间就是股票买卖的区间**

```c++
//时间复杂度O(n),空间复杂度O(n)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)  return 0;
        
        vector<int> profit(prices.size()-1);
        for(int i = 1; i < prices.size(); i++){
            profit[i-1] = prices[i] - prices[i-1];
        }
        int res = 0;
        for(int i = 0; i < profit.size(); i++){
            if(profit[i] > 0) res+=profit[i];
        }
        return res;
    }
};
//以上可以做一下优化，不使用vector.//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)  return 0;
        
        int res = 0;
        for(int i = 1; i < prices.size(); i++){
            res += max(prices[i] - prices[i-1], 0);
        }
        return res;
    }
};
```

**动态规划**

1.确定dp数组及下标含义

dp数组每个位置设置两个，0表示持有该股票，1表示不持有该股票。

dp[i]表示在第i个股票持有和不持有的最大收益是dp[i]。

2.确定递推公式

如果第i天持有该股票，有两种情况，选择最大的持有

* 在第i-1天就持有，所以在第i天继续持有。则`dp[i][0] = dp[i-1][0]`

* 在第i天买入，则在第i天持有，则`dp[i][0] = dp[i-1][1] - prices[i]`

如果在第i天不持有该股票，有两种情况，选择最大的卖出

* 在第i-1天就不持有，则第i天不持有，则`dp[i][1] = dp[i-1][1]`

* 在第i天卖出，则在第i天不持有。`dp[i][1] = dp[i-1][0]+prices[i]`

所以递推公式如下：

`dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])`

`dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])`

121题全程只能买入一次，所以在第i买入的时候是当天持有股票`dp[i][0] = -prices[i]`

本题中一只股票可以买入卖出多次，因此当第i天买入股票，则所得的现金就是昨天不持有股票的现金减去当天的票价格`dp[i-1][1] - prices[i]`

3.初始化

`dp[0][0] = -prices[i]`

`dp[0][1] = 0`

4.遍历顺序

从递推公式可以看出，dp[i]就是从dp[i-1]推导出来，因此是从前往后遍历

5.举例推导

prices = [7,1,5,3,6,4]

| `dp[0][0]` | -7   | -1   | -1   | 1    | 1    | 3    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| `dp[0][1]` | 0    | 0    | 4    | 4    | 7    | 7    |

最终输出`dp[prices.size()-1][1]`

c++代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;

        vector<vector<int>> dp(prices.size(), vector<int>(2));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        } 
        return dp[prices.size()-1][1];
    }
};
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

难度 困难

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。

示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。

示例 4： 输入：prices = [1] 输出：0

提示：
1 <= prices.length <= 10^5
0 <= prices[i] <= 10^5
```

思路解析：

本题和前两道股票问题的区别在于，本题中股票交易“**最多可以完成 两笔 交易”**。意思就是可以交易一次，可以交易两次，也可以不交易。

用动态规划五部曲来分析：

1.确定dp数组及下标含义

每天的股票有5个状态。

0表示没有状态，

1表示第一次买入，

2表示第一次卖出，

3表示第二次买入，

4表示第二次卖出。

`dp[i][j] .`第i天，状态j的股票最大现金是`dp[i][j]`

2.确定递归公式

不同状态的递归公式：

第i天状态1（第一次买入）的情况`dp[i][1]`有2种：

* 第i-1天买入，第i天保持现状，则`dp[i][1] = dp[i-1][1]`

* 第i天是第一次买入，则`dp[i][1] = dp[i-1][0]-prices[i]`

`dp[i][1]` 取两种情况的最大值`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`

第i天状态2（第一次卖出）的情况`dp[i][2]`有2种：

* 第i-1天就卖出了，然后第i天保持现状，因此`dp[i][2] = dp[i-1][2]`

* 第i天第一次卖出，则`dp[i][2] = dp[i-1][1] + prices[i]`

`dp[i][2]` 取两种情况的最大值`dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])`

第i天状态3（第二次买入）的情况`dp[i][3]`有2种：

* 第i-1天买入，第i天保持现状，则`dp[i][3] = dp[i-1][3]`

* 第i天是第二次买入，则`dp[i][3] = dp[i-1][2]-prices[i]`

`dp[i][3]` 取两种情况的最大值`dp[i][3] = max(dp[i][3] = dp[i-1][2],dp[i-1][2]-prices[i] `

第i天状态4（第二次卖出）的情况`dp[i][4]`有2种：

* 第i-1天就卖出了，然后第i天保持现状，因此`dp[i][4] = dp[i-1][4]`

* 第i天第二次卖出，则`dp[i][2] = dp[i-1][3] + prices[i]`

`dp[i][4]` 取两种情况的最大值`dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])`

3.dp数组初始化

第0天没有操作，则`dp[0][0] = 0;`

第0天第一次买入，则`dp[0][1] = -prices[0];`

第0天第一次卖出，首先卖出的操作肯定是能获取利润，如果利润比0小肯定就没有必要要这个收益了，因此初始化为0。`dp[0][2] = 0;`

第0天第二次买入，依赖第一次买入，第一次卖出。只要买入现金就会变少，因此`dp[0][3] = -prices[0]`

第0天第二次卖出，`dp[0][4] = 0`

4.确定遍历顺序

由于dp[i]取决于dp[i-1]，因此是从前往后遍历。

5.举例推导

以输入[1,2,3,4,5]为例

`dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])`

`dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])`

`dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i]`

`dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])`

| 输入                   | 1    | 2    | 3    | 4    | 5    |
| ---------------------- | ---- | ---- | ---- | ---- | ---- |
| `dp[0][0] 无状态`      | 0    | 0    | 0    | 0    | 0    |
| `dp[0][1]` 第一次买入  | -1   | -1   | -1   | -1   | -1   |
| `dp[0][2]` 第一次卖出  | 0    | 1    | 2    | 3    | 4    |
| `dp[0][3]`  第二次买入 | -1   | -1   | -1   | -1   | -1   |
| `dp[0][4]` 第二次卖出  | 0    | 1    | 2    | 3    | 4    |

利润最大的时候一定是卖出的时候，两次卖出的 最大利润就是`dp[4][4]`

c++代码如下：

```c++
//时间复杂度O(n),空间复杂度O(n * 5)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        //1.确定dp数组及下标含义：`dp[i][j] .`第i天，状态j的股票最大现金是`dp[i][j]`  五个状态
        vector<vector<int>> dp(prices.size(), vector<int>(5));

        //2.初始化 0表示没有状态，1表示第一次买入，2表示第一次卖出，3表示第二次买入，4表示第二次卖出。
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[prices.size()-1][4];
    }
};
```

空间优化

```c++
//时间复杂度O(n),空间复杂度O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        //1.确定dp数组及下标含义：`dp[i][j] .`第i天，状态j的股票最大现金是`dp[i][j]`  五个状态
        vector<int> dp(5);

        //2.初始化 0表示没有状态，1表示第一次买入，2表示第一次卖出，3表示第二次买入，4表示第二次卖出。
        dp[0] = 0;
        dp[1] = -prices[0];
        dp[2] = 0;
        dp[3] = -prices[0];
        dp[4] = 0;

        for(int i = 1; i < prices.size(); i++){
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
	}
};
```













