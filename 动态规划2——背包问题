背包问题分类如下图所示：


0-1背包

典型背包表述：有N件物品和一个最多装重量为W的背包。每个物品的重量是weight[i]，价值value[i]。每件物品只能装一次，问怎么装可以将背包价值最大化。

解法一：背包问题的暴力解法是什么样的？
每一件物品有两种状态，选还是不选，因此一次遍历可以用O(2^n)
的时间复杂度，n表示物品数量。
暴力解法是指数级别的时间复杂度，因此才需要优化。

举例：
背包最大重量是4，物品如下，问背包装物品的最大价值：


重量
价值
物品0
1
15
物品1
3
20
物品2
4
30
二维数组dp使用动态规划五步：
1.确定dp数组及下标含义。
写法一是用二维数组，dp[i][j]表示从下标 [0-i] 的物品中随意取放，放到重量为j的背包里的价值最大是多少。

2.递归公式
有两个方向确定dp[i][j]，
	* 
不放物品i，由dp[i-1][j]推导。不放物品i，背包容量是j的价值dp[i-1][j]。（物品i的重量大于背包的重量j时，无法放到背包里）
	* 
放物品i，由dp[i-1][j-weight[i]] + value[i]推导。放物品i时，说明背包的容量能放下weight[i]。那么不放物品i时的最大价值是dp[i-1][j-weight[i]]。那么放了物品i后的最大价值就是dp[i-1][j-weight[i]]+value[i].


递推公式dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i] )

3.dp数组初始化
如果背包容量是j=0时，什么物品都放不进去，则dp[i][0] = 0;
对于物品0，当背包容量>=weight[0]时才可以放进去。否则就是0


背包重量0
1
2
3
4
物品0
0
15
15
15
15
物品1
0




物品2
0




4.确定遍历顺序
看上图可以知道有两个遍历维度：物品和背包重量。其实根据递推公式先遍历物品和先遍历背包都是可以的。

从递推公式dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i] )可以看出。要知道dp[i][j]，都需要先知道dp[i-1][j], dp[i-1][j-weight[i]]。就是在dp[i][j]的左上方或者正上方。

两种遍历次序虽然不同，但是不影响dp[i][j]。选择最容易理解的方法即可。

5.举例推导dp数组

背包重量0
1
2
3
4
物品0
0
15
15
15
15
物品1
0
15
15
20
35
物品2
0
15
15
20
35
代码部分：

int test_2_dp(vector<int> &weight, vector<int> &value, int &bagweight){
    
    //1.确定二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    //2.初始化
    for(int j = 0; j < weight[0]; j++){
        dp[0][j] = value[0];
    }
    //3.遍历
    for(int i = 1; i < weight.size(); i++){
        for(int j = 0; j <= bagweight; j++){
            if(j < weight[i])
                dp[i][j] = dp[i-1][j];
            else
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
        }
    }
    return dp[weight.size() - 1][bagweight];
}

int main(){
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;
    int va = test_2_dp(weight, value, bagweight);
    cout << va << endl;
}








