## 题目序列

翻转二叉树

对称二叉树

二叉树深度

满二叉树

平衡二叉树





### 1.翻转二叉树

```
输入：                           输出：
   4                                   4
   /\                                 /\   
  2  7                               7  2
  /\ /\                             /\  /\
 1 3 6 9                            9 6 3 1
```

二叉树的遍历有前序中序后序三种，该选择那种遍历？这道题种前序后序遍历都可以，但是中序遍历会把某些节点的孩子翻转两次。

##### 递归法：

以前序遍历递归三部曲

1.确定递归函数参数及返回值

```
TreeNode *invertTree(TreeNode *root)
```

2.确定递归终止条件

```
if(root==NULL) return root;
```

3.确定单层递归逻辑

```
//先交换左右孩子节点，然后反转左子树，反转右子树
swap(root->left, root->right);
invertTree(root->left);
invertTree(root->right);
```

###### 整体代码如下

```c++
TreeNode * invertTree(TreeNode* root) {
	if(root==NULL) return root;
	swap(root->left, root->right);
	invertTree(root->left);
	invertTree(root->right);
    return root;
}
```

##### 迭代法

因为有前序后序的迭代方法，所以我们直接在该迭代方法上做修改

##### 深度优先遍历

前序遍历的迭代法（翻转二叉树）

```c++
TreeNode* invertTree(TreeNode* root) {
    if(root==NULL) return root;
    stack<TreeNode *> st;
    st.push(root);
    while(!st.empty()){
        TreeNode *node = st.top();   //中
        st.pop();
        swap(node->left, node->right);
        if(node->right) st.push(node->right); //右
        if(node->left) st.push(node->left);   //左
    }
    return root;
}
```

##### 广度优先遍历

层序遍历（翻转二叉树）

```c++
TreeNode* invertTree(TreeNode* root) {
    if(root == NULL) return root;
    queue<TreeNode *> q;
	q.push(root);
    while(!q.empty()){
        int len = q.size();
        for(int i=0;i<len;i++){
            TreeNode *node=q.front();
            q.pop();
            swap(node->left, node->right);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return root;
}
```

### 2.对称二叉树

```
输入：对称                           输入：不对称
   4                                   1
   /\                                 /\   
  2  2                               2  2
  /\ /\                               \  \
 1 1 6 6                               3  3 
```

##### 递归法

递归三部曲

1.确定递归函数参数及返回值

因为要比较的是根节点的左右子节点是否存在且值相等，因此要比较的是两个树，参数就需要左子树节点和右子树节点，返回值是bool类型

```
bool compare(TreeNode *left, TreeNode *right)
```

2.确定终止条件

```
* 左节点为空，右节点不为空， false
* 左节点不为空，右节点为空， false
* 左右节点都为空，         true
* 左右节点都不为空，值相等返回true，值不相等返回false
if(left == NULL && right != NULL) return false;
else if(left != NULL && right == NULL) return false;
else if(left == NULL & right == NULL) return true;
else if(left->val != right != val) return false;
```

2.确定单层递归逻辑

```
* 1.比较二叉树的外侧是否对称，传入左节点的左孩子，右节点的右孩子
* 2.比较二叉树的内侧是否对称，传入左节点的有孩子，右节点的左孩子
* 如果1和2都是true则返回true，否则返回false。
return compare( left->left, right->right) && compare(left->right, right->left);
```

###### **整体代码如下：**

```C++
bool compare(TreeNode* left, TreeNode* right){
    //排查异常情况
    if(left == NULL && right != NULL) return false;
	else if(left != NULL && right == NULL) return false;
	else if(left == NULL & right == NULL) return true;
	else if(left->val != right != val) return false;
    
    return compare( left->left, right->right) && compare(left->right, right->left);
}
bool isSymmetric(TreeNode* root) {
    if(root==NULL) return true;
    return isSymmetric(root->left, root->right);
}
```

##### 迭代法

这里的迭代法不是前中后序的迭代写法，本题的本质是判断两个树是否相互翻转。

##### **使用队列来比较两个树是否相互翻转。**

```c++
bool isSymmetric(TreeNode* root) {
	if(root==NULL) return true;
	queue<TreeNode *> q;
	q.push(root->left);  //将左子树头节点加入队列
	q.push(root->right); //将右子树头节点加入队列
	
	while(!q.empty()){
		TreeNode *left = q.front(); q.pop();
        TreeNode *right = q.front(); q.pop();
        if(!left && !right) return true;
        if((!left&&right) || (left&&!right) || (left->val != right->val))	return false;
        q.push(left->left);
        q.push(right->right);
        q.push(left->right);
        q.push(right->left);
	}
    return true;
}
```

**使用栈来比较两个树是否相互翻转。**

```c++
bool isSymmetric(TreeNode* root) {
	if(root==NULL) return true;
	stack<TreeNode *> st;
	st.push(root->left);  //将左子树头节点加入栈
	st.push(root->right); //将右子树头节点加入栈
    
    while(!st.empty()){
        TreeNode *left = st.top(); st.pop();
        TreeNode *right = st.top(); st.pop();
        if(!left && !right) return true;
        if((!left&&right) || (left&&!right) || (left->val != right->val))	return false;
        st.push(left->left);
        st.push(right->right);
        st.push(left->right);
        st.push(right->left);
    }
    return true;
}
```

#### 3.二叉树深度

##### 递归法

本题可以使用前序(中左右)，后序(左右中)，使用前序求的是深度，后序求的是高度。

我们使用后序（左右中）来计算树的高度。

1.确定递归函数的参数及返回值：参数是树的根节点，返回的就是树的深度，所以返回值是int类型。

```
int getdepth(TreeNode *node)
```

2.递归的终止条件：如果节点为空，则返回0；

```
if(node==NULL) return 0;
```

3.单层递归逻辑：先求左子树的高度，再求右子树的高度。然后返回左右子树中最大高度+1

```
int leftdep=getdepth(node->left);
int rightdep=getdepth(node->right);
int dep=1+max(leftdep, rightdep);
return dep;
```

###### 整体代码如下：

```c++
int getdepth(treenode* node){
    if(node == NULL) return 0;
	return  1 + max(getdepth(node->left), getdepth(node->right));
}
int maxdepth(treenode* root) {
    return getdepth(root);
}
```

###### 代码精简整理后如下：

```c++
int maxdepth(treenode* root) {
    if(root == NULL) return 0;
    return 1 + max(maxdepth(node->left), maxdepth(node->right));
}
```

从上述的递归代码里看不出是那种遍历方式。所以我们使用详细的前序遍历

```c++
int res;
void getdepth(treenode* node, int depth){
    res = depth > res ? depth: res; //中
    if(node->left == NULL && node->right == NULL) return res;
    
    if(node->left){//左
        depth++;   //深度+1
        getdepth(node->left, depth);
        depth--;   //回溯，深度-1
    }
    if(node->right){//右
        depth++;    //深度+1
        getdepth(node->right, depth);
        depth--;   //回溯，深度-1
    }
    return;
}
int maxdepth(treenode* root) {
    res=0;
    if(root==NULL) return res;
    getdepth(root, 1);
    return res;
}
```

##### 迭代法

使用二叉树层序遍历

```C++
int maxdepth(treenode* root) {
    if(root == NULL) return 0;
    int depth = 0;
    queue<treeNode *> q;
    q.push(root);
    while(!q.empty()){
        int s = q.size();
        depth++;  //记录树深度
        for(int i=0;i<s.size();i++){
            treenode *node = q.front();
            q.pop();
            
            if(node->left)  q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return depth;
}
```

#### 4.完全二叉树的节点个数(leetcode 222)

```
示例 1：输入：root = [1,2,3,4,5,6]  输出：6
示例 2：输入：root = []             输出：0
示例 3：输入：root = [1]            输出：1
```

##### 4.1先按照二叉树求深度的递归方法来求解

##### 递归法

1.确定递归函数的参数及返回值：参数就是传入的根节点，返回的是节点个数。

```
int getNodeNum(TreeNode *node)
```

2.确定终止条件：如果为空节点，则返回0，表示节点数为0

```
if(node==NULL) return 0;
```

3.确定单层递归逻辑：先求左子树的节点个数leftnum，再求右子树的节点个数rightnum，然后全部节点个数是：leftnum+rightnum+1

```
int leftnum=getNodeNum(node->left);
int rightnum=getNodeNum(node->right);
return leftnum+rightnum+1;
```

###### 所以整体代码如下：

```c++
//时间复杂度O(n),空间复杂度O(logn)，算算递归系统栈占用的时间
int getgetNodeNum(TreeNode* root){
    if(root == NULL) return 0;
    return 1+getNodeNum(node->left)+getNodeNum(node->right);
         
}
int countNodes(TreeNode* root) {
    return getgetNodeNum(root);
}
```

##### 迭代法

使用层序遍历，来统计节点数量。只需在层序模板上稍作修改即可

```c++
//时间复杂度O(n),空间复杂度O(n)
int countNodes(TreeNode* root) {
    int nodeNum=0;
    if(root==NULL) return nodeNum;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size;i++){
            TreeNode *node=q.front();
            q.pop();
            nodeNum++;  //记录节点数量
            if(node->left)  q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return nodeNum;
}
```

##### 4.2 完全二叉树

完全二叉树只有两种情况：情况一：满二叉树，情况二：最后一层叶子节点没有满，且最后一层叶子节点集中在左侧。

对于情况一：可以使用2^树深度-1来计算，根节点的深度是1

对于情况二：分别递归左孩子，右孩子。递归到某一深度时一定会有左孩子或者右孩子变成情况一，这时就可以用情况一计算。

例子：

![image-20220225194742983](D:/%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B92/md/md%E5%9B%BE%E7%89%87/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BE%8B%E5%AD%90.png)

可以看出如果整个树不是满二叉树，则递归左右孩子，直到遇到满二叉树为止。然后用公式计算满二叉树的节点。

```c++
//时间复杂度O(logn * logn)，空间复杂度O(logn)
int countNodes(TreeNode* root) {
    if(root == NULL) return 0;
    TreeNode *left = root->left;
    TreeNode *right = root->right;
    int leftlen=0, rightlen=0; //这里初始化是为了方便求满二叉树的节点数
    while(left){ //左子树深度
        leftlen++;
        left=left->left;
    }
    while(right){
        rightlen++;
        right=right->right;
    }
    if(leftlen == rightlen){  //满二叉树
        return (2 << leftlen) - 1;
    }
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

#### 5.平衡二叉树

##### 给定一棵二叉树，判断是否是平衡二叉树。

```
示例1：给定二叉树 [3,9,20,null,null,15,7]， 返回true
示例2：给定二叉树 [1,2,2,3,3,null,null,4,4]， 返回false
```

判断是否是平衡二叉树的定义是：二叉树每个节点左右子树的高度查绝对值不超过1。

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数

二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数

###### 递归三部曲

1.递归函数的参数及返回值：参数当前传入的节点，返回值是以当前节点为根节点的树的高度。

那么如果判断是否左右子树差值大于1？如果当前节点为根节点的二叉树不是平衡二叉树，则返回高度无意义了，可以返回-1来表示不是平衡二叉树。

```
//以当前节点node为根节点，返回高度。如果不是平衡二叉树返回-1
int getHeight(TreeNode *node)
```

2.递归终止条件

```
if(node==NULL) return 0;
```

3.单层递归逻辑

```
int lefth = getHeight(node->left);  //左
if(lefth == -1) return -1;
int righth = getHeight(node->right); //右
if(righth == -1) return -1;
return abs(lefth - righth) > 1 ? -1 : 1 + max(lefth, righth); //中
```

###### 整体代码如下：

```C++
int getHeight(TreeNode *node){
    if(node==NULL) return 0;
    
    int lefth=getHeight(node->left);
    if(lefth == -1) return -1;
    int righth=getHeight(node->right);
    if(righth==-1) return -1;
    
    return abs(lefth - righth) <= 1 ? 1 + max(lefth, righth) : -1;
}
bool isBalanced(TreeNode* root) {
    return getHeight(root);
}
```

#### 6.二叉树的所有路径

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

![image-20220228150942876](D:/%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B92/md/md%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.png)

这道题是从根节点-叶子节点的路径，所以需要前序遍历，这样方便让父节点指向孩子节点。

##### 递归

1. 递归函数参数及返回值。参数：要传入的根节点，记录每一条路径的path， 存放结果的res。这里递归不需要返回值。

   ```
   void traversal(TreeNode *cur, vector<int> &path, vector<string> &res)
   ```

2.递归的终止条件。找到叶子节点才算是递归终止。当前cur的左右节点为空则表示是叶子节点。找到了叶子节点，就说明找到了一条路径，用path记录路径，然后将path转成string格式，把string 放入res中。

```
if(cur->left == NULL && cur->right == NULL){  //遇到叶子节点
	string spath;
	for(int i=0;i<path.size()-1;i++){ //将path中每个值存入string中
		spath += to_string(path[i]);
		spath += "->";
	}
	spath += to_string(path[path.size()-1]); //记录最后一个节点
	res.push_back(spath); //收集到一个路径
	return;
}
```

3.确定单层递归逻辑

前序遍历目前已经处理当前节点，需要将当前节点先放入path中。

path.push_back(cur->val);

然后判断递归左右节点

```
if(cur->left){
	traversal(cur->left, path, res);
	path.pop_back();
}
if(cur->right){
	traversal(cur->right, path, res);
	path.pop_back();
}

```

###### 整体代码如下

```C++
void traversal(TreeNode *cur, vector<int> &path, vector<string> &res){
    path.push_back(cur->val);
    if(cur->left == cur->right == NULL){ //叶子节点
        string spath;
        for(int i=0;i<path.size()-1;i++{ 
            spath += to_string(path[i]);
            spath += "->";
        }
        spath += to_string(path[path.size()-1]);
        res.push_back(spath);
        return;
    }

    if(cur->left){
        traversal(cur->left, path, res);
        path.pop_back(); //回溯
    }
    if(cur->right){
        traversal(cur->right, path, res);
        path.pop_back(); //回溯
    }

        
}

vector<string> binaryTreePaths(TreeNode *root){
    vector<string> res;
    vector<int> path;
    if(root == NULL) return res;
    traversal(root, path, res);
    return res;
} 
```

### 8.左叶子之和

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

本题中要计算左叶子之和。首先要定义左叶子：左节点不为空，且左节点的没有左右孩子，那么就是左叶子。

递归法

递归的遍历顺序采用后序遍历（左右根），这样可以通过递归函数的返回值来累加求左叶子数值之和。

递归三部曲

1.递归函数的参数及返回值。无法直接判断是否是左叶子节点，需要通过节点的父节点来判断是否是左叶子，所以参数是树的根节点，返回值是数值之和。

```
int sumofLeves(TreeNode *root);
```

2.确定终止条件

```
if(root == NULL) return 0;
```

3.确定单层递归逻辑

当当前节点的左节点是叶子节点时，记录数值。然后递归左子树之和和右子树之和，相加就是整颗树的左叶子之和。

```C++
int leftvalue = sumofLeves(root->left); //左
int rightvalue = sumofLeves(root->right); //右
int midvalue = 0;
if(root->left && !root->left->left && !root->left->right){
	midvalue += root->left->val;
}
return midvalue + leftvalue + rightvalue;
```

###### 整体代码如下

```c++
int sumOfLeftLeaves(TreeNode* root) {
    if(root == NULL) return 0;

    int leftnum = sumOfLeftLeaves(root->left);
    int rightnum = sumOfLeftLeaves(root->right);
    int midvallue=0;
    if(root->left && !root->left->left && !root->left->right){
        midvallue += root->left->val;
    }
    return midvallue + leftnum + rightnum;
}
```

