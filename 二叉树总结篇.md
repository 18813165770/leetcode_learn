## 题目序列

翻转二叉树

对称二叉树

二叉树深度

满二叉树

平衡二叉树





### 1.翻转二叉树

```
输入：                           输出：
   4                                   4
   /\                                 /\   
  2  7                               7  2
  /\ /\                             /\  /\
 1 3 6 9                            9 6 3 1
```

二叉树的遍历有前序中序后序三种，该选择那种遍历？这道题种前序后序遍历都可以，但是中序遍历会把某些节点的孩子翻转两次。

##### 递归法：

以前序遍历递归三部曲

1.确定递归函数参数及返回值

```
TreeNode *invertTree(TreeNode *root)
```

2.确定递归终止条件

```
if(root==NULL) return root;
```

3.确定单层递归逻辑

```
//先交换左右孩子节点，然后反转左子树，反转右子树
swap(root->left, root->right);
invertTree(root->left);
invertTree(root->right);
```

###### 整体代码如下

```c++
TreeNode * invertTree(TreeNode* root) {
	if(root==NULL) return root;
	swap(root->left, root->right);
	invertTree(root->left);
	invertTree(root->right);
    return root;
}
```

##### 迭代法

因为有前序后序的迭代方法，所以我们直接在该迭代方法上做修改

##### 深度优先遍历

前序遍历的迭代法（翻转二叉树）

```c++
TreeNode* invertTree(TreeNode* root) {
    if(root==NULL) return root;
    stack<TreeNode *> st;
    st.push(root);
    while(!st.empty()){
        TreeNode *node = st.top();   //中
        st.pop();
        swap(node->left, node->right);
        if(node->right) st.push(node->right); //右
        if(node->left) st.push(node->left);   //左
    }
    return root;
}
```

##### 广度优先遍历

层序遍历（翻转二叉树）

```c++
TreeNode* invertTree(TreeNode* root) {
    if(root == NULL) return root;
    queue<TreeNode *> q;
	q.push(root);
    while(!q.empty()){
        int len = q.size();
        for(int i=0;i<len;i++){
            TreeNode *node=q.front();
            q.pop();
            swap(node->left, node->right);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return root;
}
```

### 2.对称二叉树

```
输入：对称                           输入：不对称
   4                                   1
   /\                                 /\   
  2  2                               2  2
  /\ /\                               \  \
 1 1 6 6                               3  3 
```

##### 递归法

递归三部曲

1.确定递归函数参数及返回值

因为要比较的是根节点的左右子节点是否存在且值相等，因此要比较的是两个树，参数就需要左子树节点和右子树节点，返回值是bool类型

```
bool compare(TreeNode *left, TreeNode *right)
```

2.确定终止条件

```
* 左节点为空，右节点不为空， false
* 左节点不为空，右节点为空， false
* 左右节点都为空，         true
* 左右节点都不为空，值相等返回true，值不相等返回false
if(left == NULL && right != NULL) return false;
else if(left != NULL && right == NULL) return false;
else if(left == NULL & right == NULL) return true;
else if(left->val != right != val) return false;
```

2.确定单层递归逻辑

```
* 1.比较二叉树的外侧是否对称，传入左节点的左孩子，右节点的右孩子
* 2.比较二叉树的内侧是否对称，传入左节点的有孩子，右节点的左孩子
* 如果1和2都是true则返回true，否则返回false。
return compare( left->left, right->right) && compare(left->right, right->left);
```

###### **整体代码如下：**

```C++
bool compare(TreeNode* left, TreeNode* right){
    //排查异常情况
    if(left == NULL && right != NULL) return false;
	else if(left != NULL && right == NULL) return false;
	else if(left == NULL & right == NULL) return true;
	else if(left->val != right != val) return false;
    
    return compare( left->left, right->right) && compare(left->right, right->left);
}
bool isSymmetric(TreeNode* root) {
    if(root==NULL) return true;
    return isSymmetric(root->left, root->right);
}
```

##### 迭代法

这里的迭代法不是前中后序的迭代写法，本题的本质是判断两个树是否相互翻转。

##### **使用队列来比较两个树是否相互翻转。**

```c++
bool isSymmetric(TreeNode* root) {
	if(root==NULL) return true;
	queue<TreeNode *> q;
	q.push(root->left);  //将左子树头节点加入队列
	q.push(root->right); //将右子树头节点加入队列
	
	while(!q.empty()){
		TreeNode *left = q.front(); q.pop();
        TreeNode *right = q.front(); q.pop();
        if(!left && !right) return true;
        if((!left&&right) || (left&&!right) || (left->val != right->val))	return false;
        q.push(left->left);
        q.push(right->right);
        q.push(left->right);
        q.push(right->left);
	}
    return true;
}
```

**使用栈来比较两个树是否相互翻转。**

```c++
bool isSymmetric(TreeNode* root) {
	if(root==NULL) return true;
	stack<TreeNode *> st;
	st.push(root->left);  //将左子树头节点加入栈
	st.push(root->right); //将右子树头节点加入栈
    
    while(!st.empty()){
        TreeNode *left = st.top(); st.pop();
        TreeNode *right = st.top(); st.pop();
        if(!left && !right) return true;
        if((!left&&right) || (left&&!right) || (left->val != right->val))	return false;
        st.push(left->left);
        st.push(right->right);
        st.push(left->right);
        st.push(right->left);
    }
    return true;
}
```

#### 3.二叉树深度

##### 递归法

本题可以使用前序(中左右)，后序(左右中)，使用前序求的是深度，后序求的是高度。

我们使用后序（左右中）来计算树的高度。

1.确定递归函数的参数及返回值：参数是树的根节点，返回的就是树的深度，所以返回值是int类型。

```
int getdepth(TreeNode *node)
```

2.递归的终止条件：如果节点为空，则返回0；

```
if(node==NULL) return 0;
```

3.单层递归逻辑：先求左子树的高度，再求右子树的高度。然后返回左右子树中最大高度+1

```
int leftdep=getdepth(node->left);
int rightdep=getdepth(node->right);
int dep=1+max(leftdep, rightdep);
return dep;
```

###### 整体代码如下：

```c++
int getdepth(treenode* node){
    if(node == NULL) return 0;
	return  1 + max(getdepth(node->left), getdepth(node->right));
}
int maxdepth(treenode* root) {
    return getdepth(root);
}
```

###### 代码精简整理后如下：

```c++
int maxdepth(treenode* root) {
    if(root == NULL) return 0;
    return 1 + max(maxdepth(node->left), maxdepth(node->right));
}
```

从上述的递归代码里看不出是那种遍历方式。所以我们使用详细的前序遍历

```c++
int res;
void getdepth(treenode* node, int depth){
    res = depth > res ? depth: res; //中
    if(node->left == NULL && node->right == NULL) return res;
    
    if(node->left){//左
        depth++;   //深度+1
        getdepth(node->left, depth);
        depth--;   //回溯，深度-1
    }
    if(node->right){//右
        depth++;    //深度+1
        getdepth(node->right, depth);
        depth--;   //回溯，深度-1
    }
    return;
}
int maxdepth(treenode* root) {
    res=0;
    if(root==NULL) return res;
    getdepth(root, 1);
    return res;
}
```

##### 迭代法

使用二叉树层序遍历

```C++
int maxdepth(treenode* root) {
    if(root == NULL) return 0;
    int depth = 0;
    queue<treeNode *> q;
    q.push(root);
    while(!q.empty()){
        int s = q.size();
        depth++;  //记录树深度
        for(int i=0;i<s.size();i++){
            treenode *node = q.front();
            q.pop();
            
            if(node->left)  q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return depth;
}
```

#### 4.完全二叉树的节点个数(leetcode 222)

```
示例 1：输入：root = [1,2,3,4,5,6]  输出：6
示例 2：输入：root = []             输出：0
示例 3：输入：root = [1]            输出：1
```

##### 4.1先按照二叉树求深度的递归方法来求解

##### 递归法

1.确定递归函数的参数及返回值：参数就是传入的根节点，返回的是节点个数。

```
int getNodeNum(TreeNode *node)
```

2.确定终止条件：如果为空节点，则返回0，表示节点数为0

```
if(node==NULL) return 0;
```

3.确定单层递归逻辑：先求左子树的节点个数leftnum，再求右子树的节点个数rightnum，然后全部节点个数是：leftnum+rightnum+1

```
int leftnum=getNodeNum(node->left);
int rightnum=getNodeNum(node->right);
return leftnum+rightnum+1;
```

###### 所以整体代码如下：

```c++
//时间复杂度O(n),空间复杂度O(logn)，算算递归系统栈占用的时间
int getgetNodeNum(TreeNode* root){
    if(root == NULL) return 0;
    return 1+getNodeNum(node->left)+getNodeNum(node->right);
         
}
int countNodes(TreeNode* root) {
    return getgetNodeNum(root);
}
```

##### 迭代法

使用层序遍历，来统计节点数量。只需在层序模板上稍作修改即可

```c++
//时间复杂度O(n),空间复杂度O(n)
int countNodes(TreeNode* root) {
    int nodeNum=0;
    if(root==NULL) return nodeNum;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size;i++){
            TreeNode *node=q.front();
            q.pop();
            nodeNum++;  //记录节点数量
            if(node->left)  q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return nodeNum;
}
```

##### 4.2 完全二叉树

完全二叉树只有两种情况：情况一：满二叉树，情况二：最后一层叶子节点没有满，且最后一层叶子节点集中在左侧。

对于情况一：可以使用2^树深度-1来计算，根节点的深度是1

对于情况二：分别递归左孩子，右孩子。递归到某一深度时一定会有左孩子或者右孩子变成情况一，这时就可以用情况一计算。

例子：

![image-20220225194742983](D:/%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B92/md/md%E5%9B%BE%E7%89%87/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BE%8B%E5%AD%90.png)

可以看出如果整个树不是满二叉树，则递归左右孩子，直到遇到满二叉树为止。然后用公式计算满二叉树的节点。

```c++
//时间复杂度O(logn * logn)，空间复杂度O(logn)
int countNodes(TreeNode* root) {
    if(root == NULL) return 0;
    TreeNode *left = root->left;
    TreeNode *right = root->right;
    int leftlen=0, rightlen=0; //这里初始化是为了方便求满二叉树的节点数
    while(left){ //左子树深度
        leftlen++;
        left=left->left;
    }
    while(right){
        rightlen++;
        right=right->right;
    }
    if(leftlen == rightlen){  //满二叉树
        return (2 << leftlen) - 1;
    }
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

#### 5.平衡二叉树

##### 给定一棵二叉树，判断是否是平衡二叉树。

```
示例1：给定二叉树 [3,9,20,null,null,15,7]， 返回true
示例2：给定二叉树 [1,2,2,3,3,null,null,4,4]， 返回false
```

判断是否是平衡二叉树的定义是：二叉树每个节点左右子树的高度查绝对值不超过1。









