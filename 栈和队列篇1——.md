## 栈和队列

### 前序

栈的特点：先进后出

队列的特点：先进先出

1.栈和队列是STL（C++标准库）里面的两个**数据结构**。但是栈stack和队列queue都**不是容器**，是**容器适配器**container adapter。

2.首先C++标准库有很多版本，STL是哪个版本呢？

三个最普遍的STL版本：

1.HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现的，HP STL是C++ STL的第一个版本，具有开源代码

2.P.J.Plauger STL 是参照HP STL实现的，被Visual C++编译器采用。

3.SGI STL参照HP STL实现，被linux的C++编译器GCC采用，SGI STL是开源软件。

栈和队列是SGI STL里面的数据结构。那么作为容器适配器，底层是用什么容器实现的呢？栈/队列的底层可以使用vector，deque，list都是可以的，主要是数组和链表的底层实现。如果没有指定底层实现，**默认是deque**为底层结构。

我们也可以指定vector作为栈的底层实现，初始化语句就是：

```C++
std::stack<int, std::vector<int>> third;  //使用vector为底层容器的栈

std::queue<int, std::list<int>> list;         //使用list为底层容器的队列
```

### 题目篇

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

难度：简单

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

* void push(int x) 将元素 x 推到队列的末尾
* int pop() 从队列的开头移除并返回元素
* int peek() 返回队列开头的元素
* boolean empty() 如果队列为空，返回 true ；否则，返回 false


说明：

你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

```
示例：输入：["MyQueue", "push", "push", "peek", "pop", "empty"] [[], [1], [2], [], [], []]  输出：
[null, null, null, 1, 1, false]
解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

**题意解析**

这个题是要用栈来实现队列。首先栈的特点是先进后出，队列的特点是先进先出。举例[1,2,3]，

对于添加一个元素而言，栈是[1],和队列[1]都是直接push；

对于删除一个元素，栈[1,2,3]删除元素就是[3]，队列删除元素是[1]，如何用栈来实现队列的先进先出？就需要始先建立栈2，如果栈2是空就将栈1里面的元素全部取出存放到另一个栈2里，然后栈2再弹出一个元素就是[1]。如果栈2不为空，则直接弹出数据即可。

peek()的定义和pop()很像，返回队列开头的元素但是不删除。因此我们可以直接复用pop()函数将要删除的元素再添加回去到栈2里，然后返回这个元素即可。

empty()，由于我们定义了两个栈，因此判断队列是否为空就需要判断两个栈是否都是空。

因此整体我们需要建设两个栈st1，st2

```C++
class MyQueue {
public:
    stack<int> st1;
    stack<int> st2;
    MyQueue() {

    }
    
    void push(int x) {
        st1.push(x);
    }
    
    int pop() {
        if(st2.empty()){
            while(!st1.empty()){
                st2.push(st1.top());
                st1.pop();
            }
        }
        int res = st2.top();
        st2.pop();
        return res;
    }
    
    int peek() {
        int res = pop();
        st2.push(res);
        return res;
    }
    
    bool empty() {
        return st1.empty() && st2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

难度：简单

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

```
示例：输入：["MyStack", "push", "push", "top", "pop", "empty"][[], [1], [2], [], [], []]
输出：[null, null, null, 2, 2, false]
解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

**题意解析**

做完上一题使用两个栈实现队列，本题的第一想法也是使用两个队列实现栈。

**两个队列实现栈**

我们先定义两个队列queue1，queue2.

push():对于push函数来说，队列和栈都是直接存放。我们使用queue1来存放元素。

pop():栈pop的时候是直接pop栈顶元素，这个元素在队列里是队列的最后一个元素。我们**始终保持queue2为空**，将queue1里面的元素一一取出放到队列2直到剩一个元素，然后queue1的front()元素就是最后要返回的元素。此时queue1是空的，我们将queue2赋值给queue1，然后清空queue2。

top():top是取栈顶元素但是不弹出，队列里有一个back()，可以直接获取到队尾的元素。

```c++
class MyStack {
public:
    queue<int> qin;
    queue<int> qou;
    MyStack() {

    }
    void push(int x) {
        qin.push(x);
    }
    
    int pop() {
        //始终保持qou为空
        int size=qin.size();
        size--;  //qin留最后一个元素
        while(size--){
            qou.push(qin.front());
            qin.pop();
        }
        int res = qin.front();
        qin.pop();
        qin = qou;  //将qou赋值给qin
        while(!qou.empty()){
            qou.pop();
        }

        return res;

    }
    
    int top() {
        return qin.back();
    }
    
    bool empty() {
        return qin.empty();
    }
};
```

**一个队列实现栈**

从第一个版本可以看出，队列2始终只是一个备份的作用，而且只在pop()里面使用到了。在pop函数里面也是用于记录保持队列1中只剩一个元素。

所以直接将从队列里拿出来的值再输入到队列队尾，这样size只剩1个时队头的元素就是栈顶元素。

```C++
class MyStack {
public:
    queue<int> q;
    MyStack() {

    }
    void push(int x) {
        q.push(x);
    }
    int pop() {
        //始终保持qou为空
        int size=q.size();
        size--;  //qin留最后一个元素
        while(size--){
            q.push(q.front());
            q.pop();
        }
        int res = q.front();
        q.pop();
        return res;
    }
    
    int top() {
        return q.back();
    }
    bool empty() {
        return q.empty();
    }
};
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

```
示例 1：输入：s = "()"     输出：true
示例 2：输入：s = "()[]{}" 输出：true
示例 3：输入：s = "(]"     输出：false
示例 4：输入：s = "([)]"   输出：false
示例 5：输入：s = "{[]}"   输出：true
```

**题意解析**

题目是给定字符串只包含6个字符串，判断是否有效。对于符号问题，一般使用栈：

由于符合是相对于的，如果有左括号（，则如果有效一定要有右括号）；如果右左中括号[，则有右中括号]；如果有左大括号{，则有右大括号}。

如果在遍历字符串时，我们遇到左括号，则在栈里放右括号，这样如果括号是对应的，则肯定有右括号，相等就可以弹出；我们遇到左中括号，则在栈里放右中括号，这样如果括号是对应的，则肯定有右中括号，相等就可以弹出；我们遇到左大括号，则在栈里放右大括号，这样如果括号是对应的，则肯定有右大括号，相等就可以弹出；

那么不相等的情况有哪些？

情况一：如果遍历字符串过程中，发现栈已经空了，则说明无效；

情况二：如果遍历字符串过程中，如果我们遇到了)]},但是栈弹出的字符和该字符不相等，则说明无效

情况三：字符串遍历完了，如果栈不空，则说明无效，如果栈为空则说明有效

```C++
class Solution {
public:
    bool isValid(string s) {
        stack<char> stack;
        for(int i = 0; i < s.length(); i++){
            if(s[i] == '(')  stack.push(')');
            else if(s[i] == '[') stack.push(']');
            else if(s[i] == '{') stack.push('}');
            else if(stack.empty() || stack.top() != s[i]) return false;
            else  stack.pop();
        }
        return stack.empty();
    }
};
```

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

难度：中等

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

有效括号组合需满足：左括号必须以正确的顺序闭合。

 

```
示例 1：输入：n = 3  输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：输入：n = 1  输出：["()"]
```


提示：

1 <= n <= 8

**题意解析**

本题是给定n，输出所有可能并且**有效**的括号组合，有些类似全组合问题，考虑**回溯法**：

**1.递归函数参数及返回值**

我们先设定一维的全局变量result，用来存放全部的有效字符串。

函数的参数：参数1：数字n；一共有n个左括号和n个右括号，用来确定目前有几个左括号或者右括号的参数，参数2：left， 参数3：right，参数四：字符串s

```c++
vector<string> result;
void backtracking(int n, int left, int right, string s)
```

2.递归终止条件

如果right > left，则说明右括号比左括号多，括号无效。

如果left==n && right==n，则说明左右括号的个数都是n，说明字符串已经结束。

```c++
if(right > left)
	return;
if(left == n && right == n){
	result.push_back(s);
	return;
}
```

**2.单层遍历逻辑**

本题中我们的参数是有left，right，则我们的遍历逻辑就应该根据括号组合是否有效来判断：

什么时候可以添加左括号？什么时候可以添加右括号？

如果左括号left < n，则我们就可以添加左括号，如果要有效，后面添加右括号就会有效

如果右括号right < left，则说明目前右括号个数少于左括号个数，如果要有效，，我们就可以添加右括号

```c++
if(left < n){
	backtracking(n, left+1, right, s+"(");
}
if(right < left){
	backtracking(n, left, right+1, s+")");
}
```

**c++代码如下：**

```c++
class Solution {
public: 
    vector<string> result;
    void backtracking(int n, int left, int right, string s){  //l表示左边括号的数量，r表示右边括号的数量
        if(right > left)
            return;
        if(left == n && right == n){
            result.push_back(s);
            return;
        }
        if(left < n){
            backtracking(n, left+1, right, s+"(");
        }
        if(right < left){
            backtracking(n, left, right+1, s+")");
        }
        
    }
    vector<string> generateParenthesis(int n) {
        backtracking(n, 0, 0, "");
        return result;
    }
};
```



