## 栈和队列

### 前序

栈的特点：先进后出

队列的特点：先进先出

1.栈和队列是STL（C++标准库）里面的两个**数据结构**。但是栈stack和队列queue都**不是容器**，是**容器适配器**container adapter。

2.首先C++标准库有很多版本，STL是哪个版本呢？

三个最普遍的STL版本：

1.HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现的，HP STL是C++ STL的第一个版本，具有开源代码

2.P.J.Plauger STL 是参照HP STL实现的，被Visual C++编译器采用。

3.SGI STL参照HP STL实现，被linux的C++编译器GCC采用，SGI STL是开源软件。

栈和队列是SGI STL里面的数据结构。那么作为容器适配器，底层是用什么容器实现的呢？栈/队列的底层可以使用vector，deque，list都是可以的，主要是数组和链表的底层实现。如果没有指定底层实现，**默认是deque**为底层结构。

我们也可以指定vector作为栈的底层实现，初始化语句就是：

```C++
std::stack<int, std::vector<int>> third;  //使用vector为底层容器的栈

std::queue<int, std::list<int>> list;         //使用list为底层容器的队列
```

### 题目篇

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

难度：简单

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

* void push(int x) 将元素 x 推到队列的末尾
* int pop() 从队列的开头移除并返回元素
* int peek() 返回队列开头的元素
* boolean empty() 如果队列为空，返回 true ；否则，返回 false


说明：

你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

```
示例：输入：["MyQueue", "push", "push", "peek", "pop", "empty"] [[], [1], [2], [], [], []]  输出：
[null, null, null, 1, 1, false]
解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

**题意解析**

这个题是要用栈来实现队列。首先栈的特点是先进后出，队列的特点是先进先出。举例[1,2,3]，

对于添加一个元素而言，栈是[1],和队列[1]都是直接push；

对于删除一个元素，栈[1,2,3]删除元素就是[3]，队列删除元素是[1]，如何用栈来实现队列的先进先出？就需要始先建立栈2，如果栈2是空就将栈1里面的元素全部取出存放到另一个栈2里，然后栈2再弹出一个元素就是[1]。如果栈2不为空，则直接弹出数据即可。

peek()的定义和pop()很像，返回队列开头的元素但是不删除。因此我们可以直接复用pop()函数将要删除的元素再添加回去到栈2里，然后返回这个元素即可。

empty()，由于我们定义了两个栈，因此判断队列是否为空就需要判断两个栈是否都是空。

因此整体我们需要建设两个栈st1，st2

```C++
class MyQueue {
public:
    stack<int> st1;
    stack<int> st2;
    MyQueue() {

    }
    
    void push(int x) {
        st1.push(x);
    }
    
    int pop() {
        if(st2.empty()){
            while(!st1.empty()){
                st2.push(st1.top());
                st1.pop();
            }
        }
        int res = st2.top();
        st2.pop();
        return res;
    }
    
    int peek() {
        int res = pop();
        st2.push(res);
        return res;
    }
    
    bool empty() {
        return st1.empty() && st2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

难度：简单

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

```
示例：输入：["MyStack", "push", "push", "top", "pop", "empty"][[], [1], [2], [], [], []]
输出：[null, null, null, 2, 2, false]
解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

**题意解析**

做完上一题使用两个栈实现队列，本题的第一想法也是使用两个队列实现栈。

**两个队列实现栈**

我们先定义两个队列queue1，queue2.

push():对于push函数来说，队列和栈都是直接存放。我们使用queue1来存放元素。

pop():栈pop的时候是直接pop栈顶元素，这个元素在队列里是队列的最后一个元素。我们**始终保持queue2为空**，将queue1里面的元素一一取出放到队列2直到剩一个元素，然后queue1的front()元素就是最后要返回的元素。此时queue1是空的，我们将queue2赋值给queue1，然后清空queue2。

top():top是取栈顶元素但是不弹出，队列里有一个back()，可以直接获取到队尾的元素。

```c++
class MyStack {
public:
    queue<int> qin;
    queue<int> qou;
    MyStack() {

    }
    void push(int x) {
        qin.push(x);
    }
    
    int pop() {
        //始终保持qou为空
        int size=qin.size();
        size--;  //qin留最后一个元素
        while(size--){
            qou.push(qin.front());
            qin.pop();
        }
        int res = qin.front();
        qin.pop();
        qin = qou;  //将qou赋值给qin
        while(!qou.empty()){
            qou.pop();
        }

        return res;

    }
    
    int top() {
        return qin.back();
    }
    
    bool empty() {
        return qin.empty();
    }
};
```

**一个队列实现栈**

从第一个版本可以看出，队列2始终只是一个备份的作用，而且只在pop()里面使用到了。在pop函数里面也是用于记录保持队列1中只剩一个元素。

所以直接将从队列里拿出来的值再输入到队列队尾，这样size只剩1个时队头的元素就是栈顶元素。

```C++
class MyStack {
public:
    queue<int> q;
    MyStack() {

    }
    void push(int x) {
        q.push(x);
    }
    int pop() {
        //始终保持qou为空
        int size=q.size();
        size--;  //qin留最后一个元素
        while(size--){
            q.push(q.front());
            q.pop();
        }
        int res = q.front();
        q.pop();
        return res;
    }
    
    int top() {
        return q.back();
    }
    bool empty() {
        return q.empty();
    }
};
```











