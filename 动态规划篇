动态规划，英文Dynamic Programing，简称DP。
步骤：
1.确定dp数组和下标的含义
2.确定递推数组
3.dp数组初始化
4.确定遍历顺序
5.举例推导dp数组
509. 斐波那契数
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。


常用的思路就是递归，每一步依赖上一步的结果。由于该题已经给出了递归公式所以直接使用。
时间复杂度O(2^n)，空间复杂度O(n)
class Solution {
public:
    int fib(int n) {
        if(n==0 || n==1) return n;
        return fib(n-1)+fib(n-2);
    }
};


使用动态规划的步骤思考：
1.确定dp数组和下标的含义，dp[i]指第i个数的斐波那契数值
2.递推数组，题目已经给出dp[i]=dp[i-1]+dp[i-2]
3.dp数组初始化dp[0]=0,dp[1]=1
4.遍历顺序，从递推公式可以看出dp数组从前往后遍历
5.举例推导数组：0 1 1 2 3 5 8 13 21 34 55

时间复杂度O(n)，空间复杂度O(n)
class Solution {
public:
    int fib(int n) {
        if(n == 0 || n == 1) return n;
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
           dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}

也可以不用维护整个序列，只需要维护两个数值就行了。
时间复杂度O(n)，空间复杂度O(1)

class Solution {
public:
    int fib(int n) {
        if(n == 0 || n == 1)  return n;
        int a = 0, b = 1, c = 0;
        for(int i=2;i<=n;i++){
            c = a + b ;
            a = b;
            b = c;
        }
        return b;
    }
}


完成动态规划基础篇的练习
