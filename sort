/**
   十大排序算法
*/

#include<iostream>
#include<vector>
#include<cmath>
using namespace std;

/*
简单排序：
冒泡排序：最好O(n)  最坏O(n2) 平均O(n2)  空间O(1)  稳定
选择排序：最好O(n2)  最坏O(n2) 平均O(n2) 空间O(1)  不稳定
*/
void BubbleSort(vector<int> &arr){
    if(arr.empty() || arr.size()==1)
        return;
    int n = arr.size();
    for(int i=0;i<n;i++){
        for(int j=0;j<n-i-1;j++){
            if(arr[j]>arr[j+1]){
                int tmp = arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=tmp;
            }
        }
    }
}

void SelectSort(vector<int> &arr){
    if(arr.empty() || arr.size()==1)
        return;
    int mins = arr[0];
    int n = arr.size();
    for(int i=0;i<n;i++){
        for(int j=i;j<n;j++){
            if(arr[j]<=mins){
                mins = arr[j];
                int tmp=arr[j];
                arr[j]=arr[i];
                arr[i]=tmp;
            }
        }
    }
}

/*
*插入排序：
简单插入排序 最好O(n)  最坏O(n2) 平均O(n2)  空间O(1)  稳定
希尔排序     最好O(n)  最坏O(n2) 平均O(n1.3)空间O(1)  不稳定
*/
void SampleInsertSort(vector<int> &arr){
    if(arr.empty() || arr.size()==1) return;
    int n = arr.size();
    for(int i=1;i<n;i++){
        int pre=i-1;
        int cur=arr[i];
        for(;pre>=0&&arr[pre]>cur;pre--){
            arr[pre+1]=arr[pre];
        }
        arr[pre+1]=cur;
    }
}

void ShellSort(vector<int> &arr){
    if(arr.empty() || arr.size()==1) return;
    int n = arr.size();
    int gap=n/2;
    while(gap>=1){
        for(int i=gap;i<n;i++){
            int pre=i-gap;
            int cur = arr[i];
            for(;pre>=0&&arr[pre]>cur;pre-=gap){
                arr[pre+gap]=arr[pre];
            }
            arr[pre+gap]=cur;
        }
        gap/=2;
    }
}


void MergeSort(vector<int> &arr){
    if(arr.size()<2) return;
    int st = 0, en =arr.size()-1;
    MergeSortH(arr, res, 0, n-1);

}

void QuickSortH(vector<int> &arr, int st, int en){
    int i=st;
    int j=en;
    int pivot = arr[st];
    if(i<j){
        while(i<j){
            while(i<j && arr[j]>=pivot) j--;
            arr[i]=arr[j];
            while(i<j && arr[i]<=pivot) i++;
            arr[j]=arr[i];
        }
        arr[i]=pivot;

        QuickSortH(arr,st, i-1);
        QuickSortH(arr,i+1, en);
    }
}

void QuickSort(vector<int> &arr){
    if(arr.empty() || arr.size()==1) return;
    int i=0, j=arr.size()-1;
    QuickSortH(arr,i, j);
}
/**
//堆排序整体的时间复杂度为O(n*log n).
*/
void adjust(vector<int> &arr, int par, int len){
    int left = par*2+1;
    int right = par*2+2;
    int parentIdx = par;
    if(left<len && arr[left]>arr[parentIdx]) parentIdx=left;
    if(right<len && arr[right]>arr[parentIdx]) parentIdx=right;
    if(parentIdx != par){
        int tmp=arr[parentIdx];
        arr[parentIdx]=arr[par];
        arr[par]=tmp;

        adjust(arr, parentIdx, len);
    }
}

void HeapSort(vector<int> &arr){
    if(arr.empty() || arr.size()==1) return;
    int n=arr.size();
    for(int i=n/2-1;i>=0;i--){
        adjust(arr, i, n);
    }
    for(int i=n-1;i>0;i--){
        int tmp=arr[0];
        arr[0]=arr[i];
        arr[i]=tmp;

        adjust(arr, 0, i);
    }
}

//计数排序 时间复杂度O(n), 空间复杂度O(n)
void CountingSort(vector<int> &arr){
    //1. 获得待排序数据的最大值,最小值
    int minx=arr[0], maxx=arr[0];
    for(int i=1;i<arr.size();i++){
        if(arr[i]<minx) minx=arr[i];
        if(arr[i]>maxx) maxx=arr[i];
    }
    //2.申请辅助空间，大小为 (max-min+1)。
    vector<int> res(maxx-minx+1);

    //3.对每个元素的频次进行统计
    for(int i=0;i<arr.size();i++){
        res[arr[i]-minx]++;
    }
    //4.输出回源数组中
    int k=0;
    for(int i=0;i<res.size();i++){
        for(int j=0;j<res[i];j++){
            arr[k++] = i+minx;
        }
    }
}

void BucketSort(vector<int> &arr){
    //1. 获得待排序数据的最大值,最小值
    int minx=arr[0], maxx=arr[0];
    for(int i=0;i<arr.size();i++){
        if(arr[i]<minx) minx=arr[i];
        if(arr[i]>maxx) maxx=arr[i];
    }
    if(arr.empty() || minx > maxx) return;

    //2.申请辅助空间，定义每个桶的大小，有多少桶
    vector<vector<int>> bucket;
    int bucketsize = 5;  //每个桶最多5个元素
    bucket.resize((maxx-minx+1)/bucketsize);

    //3.元素存储到桶中
    for(int i=0;i<arr.size();i++){
        bucket[(arr[i]-minx)/bucketsize].push_back(arr[i]);
    }

    //4.对每个桶的元素排序后，再依次放到原先的vector里
    int k=0;
    for(int i=0;i<bucket.size();i++){
        SampleInsertSort(bucket[i]); // 对每个桶里的元素排序
        for(int j=0;j<bucket[i].size();j++){
            arr[k++]=bucket[i][j];
        }
    }
}

/**
基数排序：
假设原来有一串数值如下所示：
73, 22, 93, 43, 55, 14, 28, 65, 39, 81
第一步：根据个位数的数值，将它们分配至编号0到9的桶子中，再串起来：
81, 22, 73, 93, 43, 14, 55, 65, 28, 39
第二步：根据十位数来分配，将它们分配至编号0到9的桶子中，再串起来：
14, 22, 28, 39, 43, 55, 65, 73, 81, 93
则持续进行以上的动作直至最高位数为止。
*/
void RadixSort(vector<int> &arr){
    int n = arr.size();
    if(n < 2)
        return;
    //1.获取最大值
    int maxx=arr[0];
    for(int i=0;i<arr.size();i++){
        if(arr[i]>=maxx) maxx=arr[i];
    }
    //2.获取最大值的位数
    int digit=1;
    while(maxx/10 > 0){
        ++digit;
        maxx/=10;
    }
    //3.申请空间，共10个桶
    vector<vector<int>> bucket;
    int radix = 1;
    for(int i=1;i<=digit;i++){

        bucket.clear(); //每轮清空桶
        for(int j=0;j<arr.size();j++){
            int radix = (arr[j] / radix) % 10;
            bucket[radix].push_back(arr[j]);
        }

        int k=0;
        for(int m=0;m<10;m++){
            SampleInsertSort(bucket[m]);
            for(int n=0;n<bucket[m].size();n++){
                arr[k++]=bucket[m][n];
            }
        }
        radix = radix * 10;
    }
}


int main(){
    vector<int> arr={3, 44, 38, 5, 47, 15, 36, 26};
    //十大排序算法
    //BubbleSort(arr);
    //SelectSort(arr);
    //SampleInsertSort(arr);
    //ShellSort(arr);
    MergeSort(arr);
    //QuickSort(arr);
    //HeapSort(arr);
    //CountingSort(arr);
    //BucketSort(arr);
    //RadixSort(arr);
    for(int i=0;i<arr.size();i++)
        cout<<arr[i]<<" ";
    cout<<endl;
    return 0;
}
