## 完全背包例题

518 零钱兑换II

377 组合总和IV





#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

示例 1：

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**题意解析**

通读题意，这个题“每一种面额的硬币有无限个”，整数数组 coins就是物品，每个物品的重量是coins[i]，物品的价值是coins[i]。背包的重量是amount 。本是一道完全背包的题目。要求是返回“可以凑成总金额的硬币组合数”。所以是完全背包+组合问题。

使用动态规划五部曲来解析。

1.确定dp数组及下标含义

dp[j] 表示使用0-j面额的一个或多个硬币组合凑出总金额是dp[j]的组合方式个数。

2.确定递推公式。

回忆完全背包的组合问题递推公式dp[j] += dp[j - weight[i]]

本题中的递推公式dp[j] += dp[j - weight[i]]

3.数组初始化

如果没有硬币，则组合的最大金额是0，该方法种类是1种。dp[0] = 1;

4.确定遍历顺序

完全背包的遍历顺序外层是物品还是背包？在前序中讲的物品和背包的for循环无先后顺序，但是本题中是不行的。本题中要求“并返回可以**凑成总金额的硬币组合数**”， 元素之间要求没有顺序的，题目中每个方案的个数是**组合数**。那么遍历顺序就有要求了。

注意：背包从小到大遍历，保证每个零钱可以被放置多次。

先看外层零钱，内层金额的情况：

```c++
for(int i = 0; i < coins.size(); i++){
	for(int j = coins[i]; j <= amount; j++){
		dp[j] += dp[j - coins[i]];
	}
}
```

假设coins[0] = 1, coins[1] = 5。得到的方法数量是{1，5}，{5，1}情况

再看外层金额，内层零钱的情况：

```c++
for(int j = 0; j <= amount; j++){
	for(int i = 0; i < coins.size(); i++){
		if(j - coins[i] >= 0)
			dp[j] += dp[j - coins[i]];
	}
}
```

假设coins[0] = 1, coins[1] = 5。得到的方法数量是{1，5}情况

5.推导

amount = 5, coins = [1, 2, 5]

使用coin = 1遍历

| 1    | 1    | 1    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- |

使用coin = 2遍历

| 1    | 1    | 2    | 2    | 3    | 3    |
| ---- | ---- | ---- | ---- | ---- | ---- |

使用coin = 5遍历

| 1    | 1    | 2    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {

        //1.确定dp数组及下标含义，dp[j] 表示使用0-j面额的一个或多个硬币组合凑出总金额是dp[j]的组合方式个数。
        vector<int> dp(amount + 1);

        dp[0] = 1;
       
        for(int i = 0; i < coins.size(); i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```


#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

提示：

* 1 <= nums.length <= 200
* 1 <= nums[i] <= 1000
* nums 中的所有元素 互不相同
* 1 <= target <= 1000

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

```

**题意解析：**

从题目中给定一个不同数组nums，每个元素可以使用多次，一个目标整数target。返回加和总和是target的元素组合的个数。乍一看是 完全背包+组合问题。但是示例一中提到“**顺序不同的序列被视作不同的组合**”，因此此题是**完全背包+排列问题**。

组合问题和排列问题的区别在于遍历物品遍历背包的先后顺序上。如果有不理解，可以将两种遍历顺序得出的结果手动推导一遍就明白了。

使用动规五部曲来分析：

1.确定dp数组及下标含义

dp[j] 表示使用nums数组里的0-j数值的一个或多个加和等于targetdp[j]的排列方式个数。

2.确定递推公式。

回忆完全背包的组合/排列问题递推公式`dp[j] += dp[j - weight[i]]`；本题中的递推公式`dp[j] += dp[j - weight[i]]`

3.数组初始化

如果没有nums数组时，对于0这个值的排列组合方法只有1种。对于1-4的初始化是什么呢？不确定，那么就可以认为是0，只有不会将后序的遍历结果覆盖即可。

4.确定遍历顺序

先遍历背包，再遍历物品。背包遍历从小到大遍历。

5.举例推导。

对于j = 0

| 1    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 1  dp[1] = dp[1] + dp[0] = 1

| 1    | 1    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 2  dp[2] = dp[2] + dp[1] + dp[0] = 2

| 1    | 1    | 2    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 3  dp[3] = dp[3] + dp[2] + dp[1] = 4

| 1    | 1    | 2    | 4    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 4  dp[4] = dp[4] + dp[3] + dp[2] + dp[1] = 7

| 1    | 1    | 2    | 4    | 7    |
| ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
public:
    int combinationSum4(vector<int>& nums, int target) {
        //1.确定dp数组及下标含义
        vector<int> dp(target + 1);

        //2.数组初始化
        dp[0] = 1;

        //3.遍历
        for(int j = 0; j <= target; j++){  //先遍历背包
            for(int i = 0; i < nums.size(); i++){  //再遍历物品
                //C++测试用例有超过两个树相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。
                if(j >= nums[i] && dp[j] < INT_MAX - dp[j - nums[i]])
                    dp[j] += dp[j - nums[i]];
            }
        }
        
        return dp[target];
    }
};
```


**总结：**

装满背包有几种方案时，认清遍历顺序很重要。

**求组合数：外层for循环物品，内层for循环背包**

**求排列数：外常for循环背包，内层for循环物品。**

