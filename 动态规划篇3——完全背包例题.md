## 完全背包例题

518 零钱兑换II

377 组合总和IV

322 零钱兑换

70 爬楼梯（变种）



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

示例 1：

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**题意解析**

通读题意，这个题“每一种面额的硬币有无限个”，整数数组 coins就是物品，每个物品的重量是coins[i]，物品的价值是coins[i]。背包的重量是amount 。本是一道完全背包的题目。要求是返回“可以凑成总金额的硬币组合数”。所以是完全背包+组合问题。

使用动态规划五部曲来解析。

1.确定dp数组及下标含义

dp[j] 表示使用0-j面额的一个或多个硬币组合凑出总金额是dp[j]的组合方式个数。

2.确定递推公式。

回忆完全背包的组合问题递推公式dp[j] += dp[j - weight[i]]

本题中的递推公式dp[j] += dp[j - weight[i]]

3.数组初始化

如果没有硬币，则组合的最大金额是0，该方法种类是1种。dp[0] = 1;

4.确定遍历顺序

完全背包的遍历顺序外层是物品还是背包？在前序中讲的物品和背包的for循环无先后顺序，但是本题中是不行的。本题中要求**返回可以凑成总金额的硬币组合数**”， 元素之间要求没有顺序的，题目中每个方案的个数是**组合数**。那么遍历顺序就有要求了。

注意：背包从小到大遍历，保证每个零钱可以被放置多次。

先看外层零钱，内层金额的情况：

```c++
for(int i = 0; i < coins.size(); i++){
	for(int j = coins[i]; j <= amount; j++){
		dp[j] += dp[j - coins[i]];
	}
}
```

假设coins[0] = 1, coins[1] = 5。得到的方法数量是{1，5}，{5，1}情况

再看外层金额，内层零钱的情况：

```c++
for(int j = 0; j <= amount; j++){
	for(int i = 0; i < coins.size(); i++){
		if(j - coins[i] >= 0)
			dp[j] += dp[j - coins[i]];
	}
}
```

假设coins[0] = 1, coins[1] = 5。得到的方法数量是{1，5}情况

5.推导

amount = 5, coins = [1, 2, 5]

使用coin = 1遍历

| 1    | 1    | 1    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- |

使用coin = 2遍历

| 1    | 1    | 2    | 2    | 3    | 3    |
| ---- | ---- | ---- | ---- | ---- | ---- |

使用coin = 5遍历

| 1    | 1    | 2    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {

        //1.确定dp数组及下标含义，dp[j] 表示使用0-j面额的一个或多个硬币组合凑出总金额是dp[j]的组合方式个数。
        vector<int> dp(amount + 1);

        dp[0] = 1;
       
        for(int i = 0; i < coins.size(); i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

**总结：**

装满背包有几种方案时，认清遍历顺序很重要。

**求组合数：外层for循环物品，内层for循环背包**

**求排列数：外常for循环背包，内层for循环物品。**



#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

提示：

* 1 <= nums.length <= 200
* 1 <= nums[i] <= 1000
* nums 中的所有元素 互不相同
* 1 <= target <= 1000

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

```

**题意解析：**

从题目中给定一个不同数组nums，每个元素可以使用多次，一个目标整数target。返回加和总和是target的元素组合的个数。乍一看是 完全背包+组合问题。但是示例一中提到“**顺序不同的序列被视作不同的组合**”，因此此题是**完全背包+排列问题**。

组合问题和排列问题的区别在于遍历物品遍历背包的先后顺序上。如果有不理解，可以将两种遍历顺序得出的结果手动推导一遍就明白了。

使用动规五部曲来分析：

1.确定dp数组及下标含义

dp[j] 表示使用nums数组里的0-j数值的一个或多个加和等于targetdp[j]的排列方式个数。

2.确定递推公式。

回忆完全背包的组合/排列问题递推公式`dp[j] += dp[j - weight[i]]`；本题中的递推公式`dp[j] += dp[j - weight[i]]`

3.数组初始化

如果没有nums数组时，对于0这个值的排列组合方法只有1种。对于1-4的初始化是什么呢？不确定，那么就可以认为是0，只有不会将后序的遍历结果覆盖即可。

4.确定遍历顺序

先遍历背包，再遍历物品。背包遍历从小到大遍历。

5.举例推导。

对于j = 0

| 1    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 1  dp[1] = dp[1] + dp[0] = 1

| 1    | 1    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 2  dp[2] = dp[2] + dp[1] + dp[0] = 2

| 1    | 1    | 2    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 3  dp[3] = dp[3] + dp[2] + dp[1] = 4

| 1    | 1    | 2    | 4    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 4  dp[4] = dp[4] + dp[3] + dp[2] + dp[1] = 7

| 1    | 1    | 2    | 4    | 7    |
| ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
public:
    int combinationSum4(vector<int>& nums, int target) {
        //1.确定dp数组及下标含义
        vector<int> dp(target + 1);

        //2.数组初始化
        dp[0] = 1;

        //3.遍历
        for(int j = 0; j <= target; j++){  //先遍历背包
            for(int i = 0; i < nums.size(); i++){  //再遍历物品
                //C++测试用例有超过两个树相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。
                if(j >= nums[i] && dp[j] < INT_MAX - dp[j - nums[i]])
                    dp[j] += dp[j - nums[i]];
            }
        }
        
        return dp[target];
    }
};
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)题目变种

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

```
示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**思路**

本题我们在动态规划基础篇里已经介绍过，本题在这里做一些微微改动。

**改为：每次你可以爬 1 个台阶， 2 个台阶，3个台阶... 知道m个台阶。你有多少种不同的方法可以爬到楼顶呢？**

在这个题目种1阶，2阶，2阶...直到m阶就是物品， 楼顶就是背包。问有多少种方式爬到楼顶，比如三层楼，爬到楼顶的方式可以是{1,2}，也可以是{2,1}。因此本题就是**完全背包+排列问题。**

动规五部曲来分析如下：

1.确定dp数组及下标含义

dp[j]就是上到有j个楼梯的楼顶，有dp[j]种方式。

2.确定递归数组。对于排列/组合问题的递归数组是dp[j] = dp[j] + dp[j - nums[i]]。在本题中有dp[j]有几种来源呢？dp[j-1], dp[j-2], dp[j-3]..。因此是dp[j - i]

3.dp数组初始化。

达到有0层楼梯达到楼顶，有一种方法。那么dp[0] = 1

4.确定遍历顺序。

排列问题，先访问背包，再访问物品。

5.举例推导dp数组。

c++代码如下：

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1);
        
        dp[0] = 1;
        
        for(int j = 1; j<= n; j++){  //先遍历背包
            for(int i = 1; i <= m; i++){  //再遍历物品。m是代表可以爬m个楼梯，把代码中的m改为2，就可以AC掉70题了。
                if(j - i >= 0) 
                    dp[j] = dp[j] + dp[j - i];
            }
        }
        return dp[n];
    }
};
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

```
示例 1：

输入：coins = [1, 2, 5], amount = 11  输出：3   解释：11 = 5 + 5 + 1
输入：coins = [2], amount = 3  输出：-1

```

