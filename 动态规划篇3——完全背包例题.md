## 完全背包例题

518 零钱兑换II

377 组合总和IV

322 零钱兑换

70 爬楼梯（变种）

322 零钱兑换



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

示例 1：

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**题意解析**

通读题意，这个题“每一种面额的硬币有无限个”，整数数组 coins就是物品，每个物品的重量是coins[i]，物品的价值是coins[i]。背包的重量是amount 。本是一道完全背包的题目。要求是返回“可以凑成总金额的硬币组合数”。所以是完全背包+组合问题。

使用动态规划五部曲来解析。

1.确定dp数组及下标含义

dp[j] 表示使用0-j面额的一个或多个硬币组合凑出总金额是dp[j]的组合方式个数。

2.确定递推公式。

回忆完全背包的组合问题递推公式dp[j] += dp[j - weight[i]]

本题中的递推公式dp[j] += dp[j - weight[i]]

3.数组初始化

如果没有硬币，则组合的最大金额是0，该方法种类是1种。dp[0] = 1;

4.确定遍历顺序

完全背包的遍历顺序外层是物品还是背包？在前序中讲的物品和背包的for循环无先后顺序，但是本题中是不行的。本题中要求**返回可以凑成总金额的硬币组合数**”， 元素之间要求没有顺序的，题目中每个方案的个数是**组合数**。那么遍历顺序就有要求了。

注意：背包从小到大遍历，保证每个零钱可以被放置多次。

先看外层零钱，内层金额的情况：

```c++
for(int i = 0; i < coins.size(); i++){
	for(int j = coins[i]; j <= amount; j++){
		dp[j] += dp[j - coins[i]];
	}
}
```

假设coins[0] = 1, coins[1] = 5。得到的方法数量是{1，5}，{5，1}情况

再看外层金额，内层零钱的情况：

```c++
for(int j = 0; j <= amount; j++){
	for(int i = 0; i < coins.size(); i++){
		if(j - coins[i] >= 0)
			dp[j] += dp[j - coins[i]];
	}
}
```

假设coins[0] = 1, coins[1] = 5。得到的方法数量是{1，5}情况

5.推导

amount = 5, coins = [1, 2, 5]

使用coin = 1遍历

| 1    | 1    | 1    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- |

使用coin = 2遍历

| 1    | 1    | 2    | 2    | 3    | 3    |
| ---- | ---- | ---- | ---- | ---- | ---- |

使用coin = 5遍历

| 1    | 1    | 2    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {

        //1.确定dp数组及下标含义，dp[j] 表示使用0-j面额的一个或多个硬币组合凑出总金额是dp[j]的组合方式个数。
        vector<int> dp(amount + 1);

        dp[0] = 1;
       
        for(int i = 0; i < coins.size(); i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

**总结：**

装满背包有几种方案时，认清遍历顺序很重要。

**求组合数：外层for循环物品，内层for循环背包**

**求排列数：外常for循环背包，内层for循环物品。**



#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

提示：

* 1 <= nums.length <= 200
* 1 <= nums[i] <= 1000
* nums 中的所有元素 互不相同
* 1 <= target <= 1000

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

```

**题意解析：**

从题目中给定一个不同数组nums，每个元素可以使用多次，一个目标整数target。返回加和总和是target的元素组合的个数。乍一看是 完全背包+组合问题。但是示例一中提到“**顺序不同的序列被视作不同的组合**”，因此此题是**完全背包+排列问题**。

组合问题和排列问题的区别在于遍历物品遍历背包的先后顺序上。如果有不理解，可以将两种遍历顺序得出的结果手动推导一遍就明白了。

使用动规五部曲来分析：

1.确定dp数组及下标含义

dp[j] 表示使用nums数组里的0-j数值的一个或多个加和等于targetdp[j]的排列方式个数。

2.确定递推公式。

回忆完全背包的组合/排列问题递推公式`dp[j] += dp[j - weight[i]]`；本题中的递推公式`dp[j] += dp[j - weight[i]]`

3.数组初始化

如果没有nums数组时，对于0这个值的排列组合方法只有1种。对于1-4的初始化是什么呢？不确定，那么就可以认为是0，只有不会将后序的遍历结果覆盖即可。

4.确定遍历顺序

先遍历背包，再遍历物品。背包遍历从小到大遍历。

5.举例推导。

对于j = 0

| 1    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 1  dp[1] = dp[1] + dp[0] = 1

| 1    | 1    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 2  dp[2] = dp[2] + dp[1] + dp[0] = 2

| 1    | 1    | 2    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 3  dp[3] = dp[3] + dp[2] + dp[1] = 4

| 1    | 1    | 2    | 4    | 0    |
| ---- | ---- | ---- | ---- | ---- |

对于j = 4  dp[4] = dp[4] + dp[3] + dp[2] + dp[1] = 7

| 1    | 1    | 2    | 4    | 7    |
| ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
public:
    int combinationSum4(vector<int>& nums, int target) {
        //1.确定dp数组及下标含义
        vector<int> dp(target + 1);

        //2.数组初始化
        dp[0] = 1;

        //3.遍历
        for(int j = 0; j <= target; j++){  //先遍历背包
            for(int i = 0; i < nums.size(); i++){  //再遍历物品
                //C++测试用例有超过两个树相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。
                if(j >= nums[i] && dp[j] < INT_MAX - dp[j - nums[i]])
                    dp[j] += dp[j - nums[i]];
            }
        }
        
        return dp[target];
    }
};
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)题目变种

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

```
示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**思路**

本题我们在动态规划基础篇里已经介绍过，本题在这里做一些微微改动。

**改为：每次你可以爬 1 个台阶， 2 个台阶，3个台阶... 知道m个台阶。你有多少种不同的方法可以爬到楼顶呢？**

在这个题目种1阶，2阶，2阶...直到m阶就是物品， 楼顶就是背包。问有多少种方式爬到楼顶，比如三层楼，爬到楼顶的方式可以是{1,2}，也可以是{2,1}。因此本题就是**完全背包+排列问题。**

动规五部曲来分析如下：

1.确定dp数组及下标含义

dp[j]就是上到有j个楼梯的楼顶，有dp[j]种方式。

2.确定递归数组。对于排列/组合问题的递归数组是dp[j] = dp[j] + dp[j - nums[i]]。在本题中有dp[j]有几种来源呢？dp[j-1], dp[j-2], dp[j-3]..。因此是dp[j - i]

3.dp数组初始化。

达到有0层楼梯达到楼顶，有一种方法。那么dp[0] = 1

4.确定遍历顺序。

排列问题，先访问背包，再访问物品。

5.举例推导dp数组。

c++代码如下：

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1);
        
        dp[0] = 1;
        
        for(int j = 1; j<= n; j++){  //先遍历背包
            for(int i = 1; i <= m; i++){  //再遍历物品。m是代表可以爬m个楼梯，把代码中的m改为2，就可以AC掉70题了。
                if(j - i >= 0) 
                    dp[j] = dp[j] + dp[j - i];
            }
        }
        return dp[n];
    }
};
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

```
示例 1：输入：coins = [1, 2, 5], amount = 11  输出：3   解释：11 = 5 + 5 + 1
示例 2：输入：coins = [2], amount = 3  输出：-1
示例 3： 输入：coins = [1], amount = 0 输出：0
示例 4： 输入：coins = [1], amount = 1 输出：1
示例 5： 输入：coins = [1], amount = 2 输出：2
```

**提示：**

* 1 <= coins.length <= 12
* 1 <= coins[i] <= 2^31 - 1
* 0 <= amount <= 10^4

**题意分析**

518就是零钱兑换的题目。是一个完全背包+组合的问题。本题和518的区别在于**返回可以凑成总金额所需的 最少的硬币个数** 。本题是一个完全背包的问题，但是是求最少硬币个数。

使用动态规划五部曲来分析：

1.确定dp数组以及下标含义

dp[j]：凑成总金额是j的背包所需要的最少硬币个数是dp[j]。

2.确定递推公式

dp[j]可以由dp[j - coins[i]]推导出来。首先j - coins[i]的金额所需要的最少硬币个数是dp[j - coins[i]]。那么只需要加上一个硬币coins[i]就组成dp[j]。就需要dp[j - coins[i]] + 1 个硬币。

因此**dp[j] = min (dp[j], dp[j - coins[i]] + 1)**

3.dp数组如何初始化

首先要凑成总金额是0最少需要的钱币个数是0，dp[0] = 0; 考虑递推公式的特性，dp[j] 必须初始化为一个最大值，这样在比较min时才不会被初始值覆盖。所以下标非0的原始都应该是最大值。

```
vector<int> dp(amount + 1, INT_MAX);
dp[0] = 0;
```

4.确定遍历顺序。

本题要求钱币的最小个数，那么先遍历物品再遍历钱币，还是遍历钱币再遍历物品顺序都可以，都不影响钱币的最小个数。

5.举例推导dp数组

coins = [1, 2, 5], amount = 5为例

dp[i]:

| 0    | 1    | 1    | 2    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- |

**c++代码如下：**

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```

#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

```
示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4

示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示**：1 <= n <= 104

**题意分析**

本题和上面的322零钱兑换问题基本类似。都是求形成正整数n所需要的最少的完全平方数的个数。其中完全平方数可以无限使用，平方数1、4、9、16相当于物品，正整数n相当于背包。因此是一个**完全背包求最小值**的问题。

使用动规五部曲来分析

1..确定dp数组以及下标含义

dp[j]：凑成正整数j的背包所需要的最少完全平方数的个数是dp[j]。

2.确定递推公式

dp[j]可以由dp[j - i * i]推导出来。首先凑成j - i * i的整数所需要的最少完全平方数的个数是dp[j - i * i]。那么只需要加上一个完全平方数i*i就组成dp[j]。就需要dp[j - i * i] + 1 个完全平方数

因此**dp[j] = min (dp[j], dp[j - i * i] + 1)**

3.dp数组如何初始化

首先要凑成正整数0最少需要0*0个完全平方数，dp[0] = 0; 考虑递推公式的特性，dp[j] 必须初始化为一个最大值，这样在比较min时才不会被初始值覆盖。所以下标非0的原始都应该是最大值。

```
vector<int> dp(n + 1, INT_MAX);
dp[0] = 0;
```

4.确定遍历顺序。

本题要求找到正整数n需要的最少平方数的个数，那么先物品后背包，还是先背包后物品顺序都可以，都不影响凑成正整数的最小个数。

5.举例推导dp数组

输入：n = 12   输出：3 

dp[j]数组

| 0    | 1    | 2    | 3    | 1    | 2    |
| ---- | ---- | ---- | ---- | ---- | ---- |

外层遍历背包，内层遍历物品的dp状态图

```
dp[0] = 0
dp[1] = min(dp[0] + 1) = 1
dp[2] = min(dp[1] + 1) = 2
dp[3] = min(dp[2] + 1) = 3
dp[4] = min(dp[3] + 1, dp[0] + 1) = 1
dp[5] = min(dp[4] + 1, dp[1] + 1) = 2
```

**c++代码如下：**

```c++
//版本1
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;

        for(int j = 0; j <= n; j++){  //先遍历背包
            for(int i = 1; i * i <= j; i++){  //再遍历物品
                dp[j] = min(dp[j - i * i]+1, dp[j]);
            }
        }
        return dp[n];
    }
};

//版本2
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;

        for(int i = 1; i * i <= n; i++){  //先遍历物品
            for(int j = 1; j <= n; j++){  //再遍历背包
                if(j - i * i >= 0)
                    dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```

