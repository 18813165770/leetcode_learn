## 回溯基础知识点

回溯算法和递归算法是相辅相成的，很多题目都说用递归算法来解决，是一回事。

回溯并不是很好的解法，只是**纯暴力**搜索方法。

回溯问题可以解决的问题有哪些呢？

​	**组合问题（不强调元素顺序）**

​	**切割字符串问题**

​	**子集问题**

​	**排列问题（强调元素顺序）**

​	**棋盘问题**

​	在解决所有回溯问题时，可以把问题抽象成树形结构，有终止条件的，树形结构的深度是可以用递归来处理，树的宽度是题目给定的宽度。



回溯算法的通用代码模板：

```C++
//一维数组path，二维数组result（用来存放全部结果）：全局变量path，recall
//1.递归函数的参数和返回值
void  bucktreaking(n, k, startindex){ //n:全部元素个数，k输出结果是几个元素，startindex是取路径的开始位置
	if (终止条件)  //2.确定递归的终止条件：path.size()==k
    {	收集结果   //result.push_back(path)
		return；
    }


	//3.单层递归逻辑：
	for(i=startindex,i<=n;i++){  //集合里的每个元素
    处理节点                  //path.push_back(i); 
    递归函数                  //bucktreaking(n, k, i+1); 
    回溯操作                  //path.pop(); 
    }          
}
```

## 组合问题

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。

```
示例 1：输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

示例 2：输入：n = 1, k = 1  输出：[[1]]
```


提示：

* 1 <= n <= 20
* 1 <= k <= n

**题意解析**

本题是组合问题，组合问题不考虑顺序。

**暴力解法**

对于例子n=4，k=2，如果使用暴力来解答，我们可以想到两层for循环，然后两两组合保存，就是最终结果。时间复杂度O(n^k)。

但是如果n=20，k=19，那么就需要19层for循环来解决，时间复杂度就是O(n^19)显然是不现实，会遇到超时问题。

**回溯法**

​	回溯法都是可以抽象成树形结构，可以发现最终要输出的值都在叶子节点上，那么回溯法就是使用递归来解决层数的问题。使用递归来做层嵌套，每一次递归嵌套一个for循环。

例如：n=4，k=2，则递归2层。

```
                            [1,2,3,4]
           取1[2，3，4]           取2[3,4]       取3[4]  取4[]
 取2[1,2] 取3[1,3] 取4[1,4] 取3[2,3]  取4[2,4]  取4[3,4]       
```

可以发现，[1,2,3,4]集合从左到右取数，取过的数不可重复取。

n相当于树的宽度，k相当于树的深度。

那么在取1是，[2,3,4]相当于在for循环；取2时，[3,4]相当于在for循环。

**回溯三部曲**

**1.确定递归函数的参数和返回值。**

1.1我们定义两个全局变量，一个用来存放符合单一条件的结果，一个用来存放符合全部条件的结果。

1.2递归函数需要有三个参数：

第一个参数是集合中元素的个数n，

第二个参数是集合中取多少个数k，

第三个参数是遍历的起始位置startindex。比如在集合[1,2,3,4]中取1之后，下一层递归就是从[2,3,4]中取数。这个startindex就是来表示从哪一位取数。

```c++
vector<vector<int>> result;
vector<int> path
    
void bucktreaking(int n, int k, int startindex){}
```

**2.回溯的终止条件**

什么时候达到所谓的叶子节点？path这个数组的大小如果等于k，则说明找到一个k个元素的子集，那么就停止遍历。

```
if(path.size() == k){
	res.push_back(path);
	return;
}
```

**3.单层搜索逻辑**

在树形图中可以看出，for循环是横向遍历，递归的过程是纵向遍历。

for循环每次从startindex开始遍历，然后用path保存取到的节点i。

```c++
for(int i=startindex;i<=n;i++){
	path.push_back(i);  //处理节点
	bucktreaking(n,k,i+1); //递归：控制树的纵向遍历，注意下一层搜索从i+1开始
	path.pop_back();     //回溯，撤回处理的节点
}
```

**c++代码如下**

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    //递归函数
    void bucktracking(int n, int k, int startindex){
        if(path.size() == k){  //回溯的终止条件
            result.push_back(path);
            return;
        }

        for(int i=startindex; i <= n; i++){
            path.push_back(i);
            bucktracking(n, k, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        bucktracking(n, k, 1);
        return result;
    }
};
```

**剪枝优化**

path.size(),还需要多少个元素可以达到k个元素？则是`k - path.size()`，那么最多从那个位置开始呢？`n-(k-path.size())+1`

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    //递归函数
    void bucktracking(int n, int k, int startindex){
        if(path.size() == k){  //回溯的终止条件
            result.push_back(path);
            return;
        }
        //从那个位置开始剪枝？n-(k-path.size())+1
        for(int i=startindex; i <= n-(k-path.size())+1; i++){
            path.push_back(i);
            bucktracking(n, k, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        bucktracking(n, k, 1);
        return result;
    }
};
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

难度： 中等

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。  解集不能包含重复的组合。 

```
示例 1: 输入: k = 3, n = 7  输出: [[1,2,4]]
示例 2: 输入: k = 3, n = 9  输出: [[1,2,6], [1,3,5], [2,3,4]]
```

**题意解析**

本题和[77. 组合](https://leetcode-cn.com/problems/combinations/)的区别在于，是在77题的基础上添加一个限制条件，需要每个k个数的和等于n才能输出。本题中n代表的是k个数的相加之和。有1-9个元素。

所以本题给出的条件如下：

k相当于树的深度，9是树的宽度。

**使用回溯三部曲分析**

**1.确定递归函数参数及返回值**

和77题一样，依然需要维护一个一维数组path，一个二维数组result。

这里我们定义path，result为全局变量。

接下来递归和函数需要的参数：

targetsum：目标和，也就是题目中的n

k：要求的k个数的集合

cursum：当前path里的元素的和

startindex：下一层for循环搜索的起始位置

```C++
vector<vector<int>> result;
vector<int> path;

void bucktracking(int k, int startindex, int targetsum, int cursum)
```

2.确定终止条件

终止条件就是path中元素的个数需要等于k，并且cursum  == targetsum。

```c++
if(path.size() == k and cursum == targetsum){
	result.push_back(path);
    return;
}
```

3.单层搜索的过程

本题和77的区别之一在于集合固定是[1,2,3...,9]，所以for循环固定i <= 9。处理过程中path是搜索元素，并且cursum要不断统计path中元素的和。

注意：处理过程中cursum加和，那么在回溯过程中就需要cursum减。

```c++
for(int i=startindex; i <= 9; i++){
	path.push_back(i);
    cursum += i;
    bucktracking(k, i+1, targetsum, cursum);  //i+1
    path.pop_back();  //回溯
    cursum -= i;
}
```

c++代码如下：

```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;

    void bucktracking(int k, int startindex, int targetsum, int cursum){
        if(path.size() == k and cursum == targetsum){
            result.push_back(path);
            return;
        }

        for(int i=startindex; i <= 9; i++){
            path.push_back(i);
            cursum += i;
            bucktracking(k, i+1, targetsum, cursum);
            path.pop_back();
            cursum -= i;
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        bucktracking(k, 1, n, 0);
        return result;
    }
};
```

**剪枝**

和77题的剪枝问题一样，for循环的范围可以剪枝，i <= 9 - (k - path.size()) + 1;



```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;

    void bucktracking(int k, int startindex, int targetsum, int cursum){
        if(cursum > targetsum){  //剪枝
            return;
        }
        if(path.size() == k and cursum == targetsum){
            result.push_back(path);
            return;
        }

        for(int i=startindex; i <= 9 - (k - path.size()) + 1; i++){
            path.push_back(i);
            cursum += i;
            bucktracking(k, i+1, targetsum, cursum);
            path.pop_back();
            cursum -= i;
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        bucktracking(k, 1, n, 0);
        return result;
    }
};
```

