#### 连续：



#### 不连续

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

难度： 中等

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4

示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1
```

提示：

- 1 <= nums.length <= 2500
- -10^4 <= nums[i] <= 104

**题意解析：**

**动态规划**

最长上升子序列用动态规划五部曲来分析：

1.确定dp数组及下标含义

dp[i]表示从0-i包括i的最长上升子序列的长度

2.递推数组

第i个位置的最长升上子序列等于从j=0到i-1个位置的最长升上子序列 + 1取最大值。

所以：

```
if(nums[i] > nums[j])
dp[i] = max(dp[i], dp[j] + 1);
```

3.dp[i]的初始化

对于每一个i，初始的最长升上子序列至少都是1.

4.确定遍历顺序

由于dp[i]是由j=0到i-1的位置的子序列推导出来的，那么顺序就是从前往后遍历

5.举例推导

输入：[0,1,0,3,2] dp数组的变化

| dp     | 0    | 1    | 0    | 3    | 2    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 初始化 | 1    | 1    | 1    | 1    | 1    |
| i=1    | 1    | 2    | 1    | 1    | 1    |
| i=2    | 1    | 2    | 1    | 1    | 1    |
| i=3    | 1    | 2    | 1    | 3    | 1    |
| i=4    | 1    | 2    | 1    | 3    | 3    |

**c++代码如下：**

```c++
//时间复杂度O(n),空间复杂度O(n)
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int res = 0;

        for(int i = 1; i < nums.size(); i++){
            for(int j = 0; j <= i; j++){
                if(nums[i] > nums[j]) 
                    dp[i] = max(dp[i], dp[j]+1);
            }
            if(dp[i] >= res)  //取最长的子序列
                res = dp[i];
        }
        return res;  
    }
};
```

**贪心算法+二分查找**

贪心的思想就是说要使上升子序列的长度更长，那么就需要每次上升子序列后面加的数尽可能小。

基于贪心的思路，维护一个数组dp[i]，表示长度为i的最长上升子序列的**末尾元素的最小值**。用len表示最长上升子序列的长度。起始的`len=1， dp[1] = nums[i]`;

假设当前求出的最长上升子序列的长度是len，从前往后遍历数组nums，遍历到nums[i]时：

* 如果nums[i]  > dp[len]， 那么直接加到dp数组的末尾，并且更新len = len+1；

* 如果nums[i] < dp[len]，那么我们在dp数组中找到一个位置j使得dp[j-1] < dp[j] < dp[len]， 我们把dp[j]替换成nums[i]。 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0

以输入序列[10, 9, 2, 5, 3, 7, 101, 18]，维护一个dp数组

第一步插入10,     dp = [10]       

第二步插入9，    dp = [9]    

第三步插入2，    dp = [2]

第四步插入5，    dp = [2，5]   

第五步插入3，    dp = [3，5]   

第六步插入7，    dp = [3，5，7]

第七步插入101，dp = [3，5，7，101]   

第八步插入18，  dp = [3，5，18，101] 

最终最长上升子序列长度是4。

代码如下：

```c++
//时间复杂度O(nlogn),遍历整个数组是O(n),每次在数组里二分查找O(logn)。
//空间复杂度O(n)
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size(); 
        if(n == 0) return 0;
        
        vector<int> dp(n+1, 0);
        int len = 1; 
        dp[len] = nums[0];

        for(int i = 1; i < n; i++){
            if(nums[i] > dp[len])
                dp[++len] = nums[i];
            else{        //二分查找
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while(l <= r){
                    int mid = (l + r) / 2;
                    if(dp[mid] < nums[i]){
                        l = mid + 1;
                        pos = mid;
                    }else{
                        r = mid - 1;
                    }
                }
                dp[pos + 1] = nums[i];  //只是替换，不需要len+1；
                
            }
        }
        return len;
    }
};
```

#### [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

```
示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。

示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。
```

提示：

- 0 <= nums.length <= 10^4
- -10^9 <= nums[i] <= 10^9

本题和上一题[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)的区别就是本题中要求子序列是连续递增的。

使用动态规划五部曲来分析：

1.确定dp数组及下标的含义

dp[i]表示从0到i包括i在内的所有数组元素，连续递增的子序列的长度是dp[i]

2.递推公式

因为要求子序列是连续递增的，因此如果nums[i] > nums[i-1], 则dp[i] = dp[i-1] + 1; 否则就不是连续递增的，dp[i]不变

3.初始化

每个元素的子序列的长度都是最小是1，就是nums[i]这一个元素。所以dp[i] = 1;

4.遍历顺序

dp[i]有时候是由dp[i-1]推导出来的，因此遍历是从前往后遍历

5.举例分析

输入：nums = [1,3,5,4,7]    输出：3

| 1    | 1    | 2    | 3    | 1    | 2    |
| ---- | ---- | ---- | ---- | ---- | ---- |

然后最长连续递增子序列长度就是dp数组里的最大值。

```c++
//时间复杂度O(n), 空间复杂度O(n)
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size()+1, 1);
        int res = 1; 
        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] < nums[i])
                dp[i] = dp[i-1] + 1;
            if(dp[i] > res) 
                res = dp[i];
        }
        return res;
    }
};
```

当然，上述代码可以优化，因为判断条件就是nums[i + 1] > nums[i]，那么count++，否则就是1，因此记录count最大值就可以了

```c++
//时间复杂度O(n), 空间复杂度O(1)
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;

        int count = 1; 
        int res = 1;

        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] < nums[i])
                count = count + 1;
            else
                count = 1;

            if(count > res)
                res = count;
        }
        return res;
    }
};
```

#### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

难度：中等

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

```
示例：
输入：A: [1,2,3,2,1]  B: [3,2,1,4,7]
输出：3  解释：长度最长的公共子数组是 [3, 2, 1] 。
```

提示：

* 1 <= len(A), len(B) <= 1000
* 0 <= A[i], B[i] < 100

**题意分析**

本题是求两个数组中公共的、长度最长的子数组的长度，子序列默认不连续，子数组默认连续。

**动态规划**

1.确定dp数组及下标含义

因为提供了两个数组，因此dp数组是二维的。`dp[i][j]`表示A数组结尾是下标i-1，B数组结尾是下标j-1的数组可以得到的最长子数组的长度是`dp[i][j]`。

为什么不是A数组下标是i，B数组下标是j的数组呢？建立二维数组时，如果习惯在每行每列都先空一行，则就是上述的表示方式。

2.确定递推公式

如果A[i-1]和B[i-1]相等，则`dp[i][j] = dp[i-1][j-1] + 1`。该公式可以通过题意来得到。从递推公式也可以看出遍历从1开始

3.初始化

由于我们先添加一空行空列，则`dp[0][j], dp[i][0]`其实都是没有意义的，但是为了满足递推公式的推理，我们可以初始化`dp[0][j] = 0, dp[i][0] = 0`

4.确定遍历顺序

本题二维数组先遍历A后遍历B，或者先遍历B后遍历A都是可以的。

从递推公式中可以看出`dp[i][j]`是由`dp[i-1][j-1]`推导得出，因此遍历顺序是从前往后的

5.举例推导

输入：A: [1,2,3,2,1]   B: [3,2,1,4,7] 输出：3

|        | B:**** | 3    | 2    | 1    | 4    | 7    |
| ------ | ------ | ---- | ---- | ---- | ---- | ---- |
| **A:** | 0      | 0    | 0    | 0    | 0    | 0    |
| **1**  | 0      | 0    | 0    | 1    | 0    | 0    |
| **2**  | 0      | 0    | 1    | 0    | 0    | 0    |
| **3**  | 0      | 1    | 0    | 0    | 0    | 0    |
| **2**  | 0      | 0    | 2    | 0    | 0    | 0    |
| 1      | 0      | 0    | 0    | 3    | 0    | 0    |

维护一个result，每次把公共的、长度最长的子数组的长度赋值给result。

c++代码如下：

```c++
//时间复杂度O(m * n), m是nums1的长度，n是nums2的长度。空间复杂度O(m*n).360ms
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1));

        for(int i = 0; i < dp.size(); i++)
            dp[i][0] = 0;
        for(int j = 0; j < dp[0].size(); j++)
            dp[0][j] = 0;
        
        int res = 0;
        for(int i = 1; i <= nums1.size(); i++){
            for(int j = 1; j <= nums2.size(); j++){
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                if(dp[i][j] > res)
                    res = dp[i][j];
            }
        }

        return res;
    }
};
```

我们可以看出`dp[i][j] = dp[i-1][j-1]`推导出来的，那么压缩为一维数组，则dp[j]是由dp[j-1]推导出来的。

```c++
//时间复杂度O(m*n),m是nums1的长度，n是nums2的长度。空间复杂度O(m).352ms
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<int> dp(nums2.size() + 1, 0);
        int res = 0;

        for(int i = 1; i <= nums1.size(); i++){
            for(int j = 1; j <= nums2.size(); j++){
                if(nums1[i-1] == nums2[j-1])
                    dp[j] = dp[j-1] + 1;
                else dp[j] = 0; // 注意这里不相等的时候要有赋0的操作
                
                if(dp[j] > res)
                    res = dp[j];
            }
        }
        return res;
    }
};
```

**滑动窗口**

我们注意到之所以两个数组的重复子数组位置要比较多次，是因为重复子数组在两个数组中的位置可能不同。比如A=[3,6,1,2,4], B=[7,1,2,9]。最长重复子数组是[1,2]，在A和B中的位置不同。

如果知道了开始位置，就可以直接把A和B对齐。

滑动窗口的方式就是枚举A和B所有的对齐方式。对齐方式有两种：

第一种：保持A不动，B的首元素与A的某个元素对齐；

第二种：保持B不动，A的首元素与B的某个元素对齐。

```c++
//时间复杂度O(m+n)*O(min(m,n)) A的长度m，B的长度n, 空间复杂度O(1).136 ms
class Solution {
public:
    int maxfindlen(vector<int>& nums1, vector<int>& nums2, int addA, int addB, int len){
        int res = 0, k = 0;
        for(int i = 0; i < len; i++){
            if(nums1[addA + i] == nums2[addB + i]){
                k += 1;
            }else{
                k = 0;
            }
                
            if(k > res)
                res = k;
        }
        return res;
    }

    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        int res = 0;
        //保持nums1不动，将nums2的首元素与nums1的某个元素对齐
        for(int i = 0; i < m; i++){
            int len = min(m-i, n);
            int maxlen = maxfindlen(nums1, nums2, i, 0, len);
            res = max(res, maxlen);
        }
        

        //保持nums2不动，将nums1的首元素与nums2的某个元素对齐
        for(int j = 0; j < n; j++){
            int len = min(m, n-j);
            int maxlen = maxfindlen(nums1, nums2, 0, j, len);
            res = max(res, maxlen);
        }
        
        return res;
    }
};
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

难度： 中等

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

```
示例 1: 输入：text1 = "abcde", text2 = "ace"  输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。

示例 2:输入：text1 = "abc", text2 = "abc"  输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。

示例 3:输入：text1 = "abc", text2 = "def"  输出：0
解释：两个字符串没有公共子序列，返回 0。
```

提示:

- 1 <= text1.length <= 1000
- 1 <= text2.length <= 1000 输入的字符串只含有小写英文字符。

**题意分析**

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)是求两个数组都存在的子数组，子数组是连续的，本题中是求两个字符串都存在的子序列，子序列是不连续的。

**动态规划**

1.dp数组及下标含义

由于给定两个字符串，设定二维dp数组。`dp[i][j]`表示下标从（0，i-1）的text1的字符串和从（0，j-1）的text2字符串最长公共子序列的长度是`dp[i][j]`。为什么是从（0，i-1）不是从（0，i）呢？因为我们在形成二维数组时增加一行一列。也便于后序递推公式的推导

2.递推公式

主要有两种情况：text1[i-1]与text2[j-1]相等和不相等：

* 如果text1[i-1] == text2[j-1]那么`dp[i][j] = dp[i-1][j-1] + 1`

* 如果text1[i-1] != text2[j-1]那么就看text1[0,i-2]与text2[0,j-1]的最长公共子序列，text1[0,i-1]与text2[0,j-2]的最长公共子序列那个最大。

 `dp[i][j] = max(dp[i][j-1], dp[i-1][j])`

3.初始化

如果text1或者text2长度是0，那么子序列的长度是0。因此`dp[i][0] = 0, dp[0][j] = 0`

4.确定遍历顺序

从递推公式可以看出有三个方向可以得出`dp[i][j]`。`dp[i][j]`是由`dp[i-1][j-1]`或者`dp[i-1][j]`,`dp[i][j-1]`推导出来的。因此遍历顺序是前往后。

先遍历text1后遍历text2，或者先遍历text2后遍历text1都是可以的。

5.举例推导

输入：text1 = "abcde", text2 = "ace"  输出：3

|           | text2 | a    | c    | e    |
| --------- | ----- | ---- | ---- | ---- |
| **text1** | 0     | 0    | 0    | 0    |
| **a**     | 0     | 1    | 1    | 1    |
| **b**     | 0     | 1    | 1    | 1    |
| c         | 0     | 1    | 2    | 2    |
| **d**     | 0     | 1    | 2    | 2    |
| **e**     | 0     | 1    | 2    | 3    |

最终的结果是`dp[text1.size()][text2.size()]`

**c++代码分析如下：**

```c++
//时间复杂度O(m*n)  m是text1的长度，n是text2的长度  空间复杂度O(m*n)
class Solution {
public:
	int longestCommonSubsequence(string text1, string text2) {

        vector<vector<int>> dp(text1.size()+1, vector<int>(text2.size() + 1, 0));

        for(int i = 1; i <= text1.size(); i++){
            for(int j = 1; j <= text2.size(); j++){
                if(text1[i - 1] == text2[j - 1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[text1.size()][text2.size()];
    }
};
```

#### [1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

难度： 中等

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

```
示例 1：输入：nums1 = [1,4,2], nums2 = [1,2,4]   输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。

示例 2：输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]  输出：3

示例 3：输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]   输出：2
```


提示：

* 1 <= nums1.length <= 500
* 1 <= nums2.length <= 500
* 1 <= nums1[i], nums2[i] <= 2000

**思路分析**

题目中表述，绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，只要 nums1[i] == nums2[j]，绘制的直线不与任何其他连线（非水平线）相交。

直线不相交的，也就是说要在nums1和nums2中找到一个公共的子序列，并且该子序列顺序不能变则不相交。

比如

输入：nums1 = [1,4,2], nums2 = [1,2,4]   输出：2

1    4   2

|       \

1    2   4

因此本题就变成和[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)一样的题目了，只需要将代码里字符串的名称改了就可以直接使用。

所以这里不做动态规划分析，直接上代码

```c++
//时间复杂度O(m*n)  m是nums1的长度，n是nums2的长度  空间复杂度O(m*n)
class Solution {
public:
	int maxUncrossedLines(vector<int> &nums1, vector<int> &nums2) {

        vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size() + 1, 0));

        for(int i = 1; i <= nums1.size(); i++){
            for(int j = 1; j <= nums2.size(); j++){
                if(nums1[i - 1] == nums2[j - 1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[nums1.size()][nums2.size()];
    }
};
```

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

难度： 简单

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4]  输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：输入：nums = [1]  输出：1

示例 3：输入：nums = [0]  输出：0

示例 4：输入：nums = [-1] 输出：-1

示例 5：输入：nums = [-100000] 输出：-100000
```


提示：

* 1 <= nums.length <= 3 * 104
* -105 <= nums[i] <= 105

**题意分析**

本题是从数组里找到一个具有最大和的连续子数组，因为数组的长度>=1，因此连续子数组的最大和最少都是num[0]。使用动态规划分析

1.确定dp数组及下标含义

因为数组是一维的，那么dp数组我们定义一维，dp[i]表述从0-i包括i在内的元素所形成的连续子数组最大和是dp[i]

2.递推公式

什么可以推导出dp[i]？从一维数组上看，dp[i]依赖于dp[i-1]，以及nums[i]

如果加上nums[i]后，连续子数组的最大和`dp[i] = dp[i-1]+nums[i]`

如果nums[i]本身就比`dp[i-1]+nums[i]`大，那么`dp[i] = nums[i]`。

两者取最大值`dp[i] = max(dp[i-1] + nums[i], nums[i])`

3.初始化

因为数组最少有一个元素，因此我们先判断一下数组的长度，如果==1， 返回nums[i]

如果数组的长度>1, 就需要上面的递推公式了，此时我们定义dp[0]的最大和就是`dp[0] =nums[0];`

4. 遍历顺序：  从前往后遍历

5. 举例推导

   输入：nums = [-2,1,-3,4,-1,2,1,-5,4]  输出：6

   dp数组如下：

   | -2   | 1    | -2   | 4    | 3    | 5    | 6    | 1    | 5    |      |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

   最终每个位置都有一个连续最大子数组的和，选取dp数组里的最大值就是最终输出值。

   **c++代码分析**

```c++
//时间复杂度O(n), 空间复杂度O(n)
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];

        vector<int> dp(nums.size() + 1);

        dp[0] = nums[0];
        int res = dp[0];
        
        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(nums[i], dp[i-1] + nums[i]);
            if(dp[i] > res)
                res = dp[i];
        }
        return res;
    }
};
```
问题子序列5题1001完成
动态规划

