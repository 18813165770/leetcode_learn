动态规划，英文Dynamic Programing，简称DP。
步骤：
1.确定dp数组和下标的含义
2.确定递推数组
3.dp数组初始化
4.确定遍历顺序
5.举例推导dp数组
509. 斐波那契数
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。


常用的思路就是递归，每一步依赖上一步的结果。由于该题已经给出了递归公式所以直接使用。
时间复杂度O(2^n)，空间复杂度O(n)
class Solution {
public:
    int fib(int n) {
        if(n==0 || n==1) return n;
        return fib(n-1)+fib(n-2);
    }
};


使用动态规划的步骤思考：
1.确定dp数组和下标的含义，dp[i]指第i个数的斐波那契数值
2.递推数组，题目已经给出dp[i]=dp[i-1]+dp[i-2]
3.dp数组初始化dp[0]=0,dp[1]=1
4.遍历顺序，从递推公式可以看出dp数组从前往后遍历
5.举例推导数组：0 1 1 2 3 5 8 13 21 34 55

时间复杂度O(n)，空间复杂度O(n)
class Solution {
public:
    int fib(int n) {
        if(n == 0 || n == 1) return n;
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
           dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}

也可以不用维护整个序列，只需要维护两个数值就行了。
时间复杂度O(n)，空间复杂度O(1)

class Solution {
public:
    int fib(int n) {
        if(n == 0 || n == 1)  return n;
        int a = 0, b = 1, c = 0;
        for(int i=2;i<=n;i++){
            c = a + b ;
            a = b;
            b = c;
        }
        return b;
    }
}


70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶


如果使用递归的方法解题：
时间复杂度O(2^n)，空间复杂度O(n)。可以画出递归树
class Solution {
public:
    int climbStairs(int n) {
        if(n==1 || n==2) return n;
        return climbStairs(n-1) + climbStairs(n-2);
    }
};


使用动态规划的步骤思考：
1.确定dp数组和下标的含义，我们让dp[i]:指爬到第i层楼梯有dp[i]种方法
2.递推数组:
   比如dp[i-1]就是爬到i-1的位置有dp[i-1]种方法，那么我们再爬1节台阶就到了dp[i];
   比如dp[i-2]就是爬到i-2的位置有dp[i-2]种方法，那么我们再爬2节台阶就到了dp[i];
   所以确定递推公式：dp[i]=dp[i-1]+dp[i-2]
3.dp数组初始化
   dp[0]的代表爬到第0层的方法，有的人认为是1，有的人认为是0，主要如果是1可以更接近于后序的序列，这里可以先不考虑dp[0]。首先可以确定dp[1]=1，dp[2]=2，因此初始化可以从这里开始。
4.遍历顺序，从递推公式可以看出dp数组从前往后遍历
5.举例推导数组：1 1 2 3 5 8 13 21 34 55
时间复杂度O(n)，空间复杂度O(n)


class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1);
        dp[1]=1,dp[2]=2;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
};


也可以不用维护整个序列，只需要维护两个数值就行了。
时间复杂度O(n)，空间复杂度O(1)
class Solution {
public:
    int climbStairs(int n) {
        int a = 1;
        int b = 2;
        int c = 0;
        for(int i=3;i<=n;i++){
            c = a + b;
            a = b;
            b = c;
        }
        return b;
    }
};
746. 使用最小花费爬楼梯

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

示例 1：

输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
 示例 2：

输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
 
提示：
cost 的长度范围是 [2, 1000]。
cost[i] 将会是一个整型数据，范围为 [0, 999] 。

题意解析：每爬一个楼梯需要消耗花费值cost[i]，
使用动态规划的步骤思考：
1.确定dp数组和下标的含义，选择dp[i]代表爬到第i个楼梯需要消耗发花费。给定有cost数组，那么用户能爬到的数量就是dp[cost.size()]。
2.递推数组，题目中给定一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
   比如dp[i-1]就是爬到i-1的位置花费dp[i-1]，那么我们再爬1节台阶就到了dp[i]，到dp[i]还需要花费cost[i]，所以dp[i-1]+cost[i];
   比如dp[i-2]就是爬到i-2的位置花费dp[i-2]，那么我们再爬2节台阶就到了dp[i]，到dp[i]还需要花费cost[i]，所以dp[i-2]+cost[i];;
   所以确定递推公式：dp[i]的花费 = min(dp[i-1]，dp[i-2])+cost[i]。为什么是加cost[i]，题目中指明：每当你爬上一个阶梯你都要花费对应的体力值
3.dp数组初始化
初始化全部dp不可能，我们可以初始化
    vector<int> dp(cost.size());
    dp[0] = cost[0];
    dp[1] = cost[1];
4.遍历顺序，由于是模拟走台阶，因此从前往后遍历cost数组就可以了
5.举例推导数组：

cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
        0   1   2  3  4  5    6  7   8   9
dp   = [1, 100, 2, 3, 3, 103, 4, 5, 104, 6]  所以最后返回6. min(dp[cost.size()-1], dp[cost.szie()-2])

代码：时间复杂度O(n)，空间复杂度O(n)
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2;i<n;i++){
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i];
        }
        return min(dp[n-1], dp[n-2]);
    }
};

也可以不用维护整个序列，只需要维护两个数值就行了。
时间复杂度O(n)，空间复杂度O(1)
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        int dp[2];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2;i<n;i++){
            int c = min(dp[0], dp[1]) + cost[i];
            dp[0] = dp[1];
            dp[1] = c;
        }
        return min(dp[0], dp[1]);
    }
};

62. 不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
示例 1：
输入：m = 3, n = 7
输出：28

示例 2：
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

题意解析，从m*n的网格的左上角移动到右下角有几种方式，每次只能移动1格。
如果用动态规划来理解：
1.确定dp数组和下标的含义：从（0，0）出发，dp[i][j]代表第i行第j列的位置有几种情况。
2.确定递归公式：
dp[i][j]的位置只能是从dp[i][j-1]和dp[i-1][j]的位置移动1格到达，因此dp[i][j] = dp[i-1][j] + dp[i][j-1]。
3.初始化：
我们首先可以初始化m*n网格的第一行和第一列的情况,从（0,0）到（i，0）的路径只有1条，到（0，j）的路径也是只有1条。也就是说dp[i][0] = 1, dp[0][j] = 1;
4.遍历的方向，从网格的左上角到右下角的位置。
5.遍历一个数组：
start   1    1
1        2     3
1        3     6
时间复杂度O(m*n)，空间复杂度O(m*n)
class Solution {
public:
    int uniquePaths(int m, int n) {
        //1.定义一个数组
        vector<vector<int>> dp(m, vector<int>(n, 0));
        //2.初始化
        for(int i = 0; i < m; i++)
            dp[i][0] = 1;
        for(int j = 0; j < n; j++)
            dp[0][j] = 1;
        
        //3.遍历
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};

上面代码是一个二维数组，如果我们用一维数组来表示，需要用和列一样长的数组dp(n)。对第二行的每列值覆盖到第一行的对应列值上
时间复杂度O(m*n)，空间复杂度O(n)

class Solution {
public:
    int uniquePaths(int m, int n) {
        //1.定义一个数组
        vector<int> dp(n);
        //2.初始化
        for(int j = 0; j < n; j++) dp[j]=1;
        
        //3.遍历
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[j] = dp[j] + dp[j-1];
            }
            
        }
        return dp[n-1];
    }
};

方法三：组合问题。

m行n列，转成二叉树就是到达终点，无论怎么走到终点都需要m+n-2步。而m+n-2步中一定有m-1步是向下走，那么给你m+n-2个不同的数，随便取m-1个数有几种取法。
C（m+n-2, m-1）。
时间复杂度O（m），空间复杂度O（1）


3道动态规划基础题：
62.不同路径
63. 不同路径 II
343. 整数拆分
96.不同的二叉搜索树

63. 不同路径 II一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -> 向右 -> 向下 -> 向下2. 向下 -> 向下 -> 向右 -> 向右

使用动态规划的思路：1.确定dp数组种值含义：dp[i][j]是代表第i行第j列有几种可能路径。从（0，0）开始到（m,n）结束
2.dp数组的递归公式：if(ob(i,j)==1) 0 else dp[i][j] = dp[i][j-1]+dp[i-1][j]
3.数组初始化，由于从数组的（0，0）开始遍历，第一行和第一列都是只有一种路径，所以如果（i,j）!= 1 则赋值1。因为如果有障碍物1，我们标记为0.
4.数组遍历：从（0，0）到（m,n），如果(dp[i][j-1],dp[i-1][j])种有值是-1，则直接去另一个值作为结果。
5.遍历该过程
0  0  0 
0  -1 0
0  0  0

0  1  1 
1  0  1
1  1  2

class Solution {public:    
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) 
{        int m = obstacleGrid.size();        
         int n = obstacleGrid[0].size();        
         vector<vector<int>> dp(m, vector<int>(n, 0));        
         for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;       
         
         for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;        
         for (int i = 1; i < m; i++) {            
             for (int j = 1; j < n; j++) {               
                  if (obstacleGrid[i][j] == 1) continue;                
                  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];            
             }        
         }       
return dp[m - 1][n - 1];   
}};



