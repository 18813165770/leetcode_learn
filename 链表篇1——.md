## 链表

#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

难度：简单

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

```
示例 1：输入：head = [1,2,6,3,4,5,6], val = 6  输出：[1,2,3,4,5]
示例 2：输入：head = [], val = 1  输出：[]
示例 3：输入：head = [7,7,7,7], val = 7 输出：[]
```

**题意解析**

从链表中删除一个元素的操作：如果`cur->next->val == val , ListNode *tmp = cur->next; cur->next=cur->next->next;`。同时在c，c++里面需要在内存中清理该节点`delete tmp;`

删除链表的操作有三种方式：

**直接在原链表进行删除操作**

​	当删除节点是头节点，由于头节点没有前一个节点，则需要将头节点后移一位，就从链表中删除了一个头节点

​	当删除节点不是头节点，则需要将待删除节点的下一个节点赋给上一个节点

**设置虚拟头节点进行删除操作**

则所有节点都可以用统一方式删除。 `cur->next=cur->next->next;`

**递归**

比如：head = [1,2,3,4,5], val = 3

递操作：从头节点开始调用递归函数removeElements，直到(head->next==NULL) 到达链表结尾，结束递操作。

1 head=1, head->next=2

1->2 head=2, head->next=3

1->2->3 head=3, head->next=4

1->2->3->4 head=4, head->next=5

1->2->3->4->5 head=5, head->next=NULL

归操作：看head

5->null

4->5

3->4->5， if(head->val==val) return head->next

2->4->5,   (removeElements函数返回的是head->next)

1->2->4->5

removeElements函数的返回值来控制新的链表：head->val == val ? head->next:head;

方法一：**直接在原链表进行删除操作**

```C++
//时间复杂度O(n), 空间复杂度O(1)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //方法一：直接在源链表上删除，不建立虚拟节点
        //删除头节点
        while(head != NULL && head->val == val){  //这里是while
            ListNode *tmp = head;
            head = head->next;
            delete tmp;
        }

        //删除非头节点
        ListNode *cur = head;
        while(cur != NULL && cur->next != NULL){
            if(cur->next->val == val){
                ListNode *tmp  = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }else{
                cur = cur->next;
            }
        }
        return head;
    }
};
```

方法二：**设置虚拟头节点进行删除操作**

```C++
//时间复杂度O(n), 空间复杂度O(1)
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //方法二：建立虚拟节点
        ListNode *dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *cur = dummy;
        while(cur->next != NULL){
            if(cur->next->val == val){
                ListNode *tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            }else{
                cur = cur->next;
            }
        }
        head = dummy->next;
        delete dummy;
        return head;
    }
};
```

方法三：**递归**

缺点：递归层数过深，容易导致栈溢出

```c++
//时间复杂度O(n), 空间复杂度O(n)
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //方法三：递归
        if(head == NULL)
            return head;
        head->next = removeElements(head->next, val);
        return head->val == val ? head->next:head;
    }
};
```

#### [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

难度：中等

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```
示例：
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

**题意解析**

这个题是设计链表的五个接口，而链表的操作有两种方式：

直接在原来的链表上操作 / 设置虚拟头节点进行操作。

下来通过设置虚拟节点来进行五个接口的设计。

```C++
class MyLinkedList {
public:
    struct LinkedNode{
        int val;
        LinkedNode * next;
        LinkedNode(int val):val(val), next(nullptr){}
    };
    MyLinkedList() {
		dummy = new LinkedNode(-1);
        _size=0;
    }
    
    int get(int index) {
		if(index < 0 || index > (_size - 0))
            return -1;
        LinkedNode *cur = dummy->next;
        while(index--){
            cur = cur -> next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
		LinkedNode *tmp = new LinkedNode(val);
        tmp->next = dummy->next;
        dummy->next = tmp;
        
        _size++;
    }
    
    void addAtTail(int val) {
		LinkedNode *tmp = new LinkedNode(val);
        LinkedNode *cur = dummy->next;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = tmp;
        _size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index > _size) return;
        
		LinkedNode *tmp = new LinkedNode(val);
        LinkedNode *cur = dummy;
        while(index--){
            cur = cur->next;
        }
        tmp->next = cur->next;
        cur->next = tmp;
        
        _size++;
    }
    
    void deleteAtIndex(int index) {
		if(index >= _size || index < 0) return;
        LinkedNode *cur = dummy;
        while(index--){
            cur = cur -> next;
        }
        LinkedNode *del = cur -> next;
        cur -> next = cur->next->next;
        delete del;
        _size--;
        
    }
private:
    int _size;
    LinkedNode* dummy;
};

```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**双指针法**：

```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == null || head->next == null)
            return head;
        
        ListNode *cur = head;
        ListNode *pre = nullptr;
        ListNode *tmp = nullptr;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

递归法

递归法和双指针是一样的逻辑，同样当cur为空的时候结束循环，不断将cur指向pre过程。

初始化：cur=head；pre=null。

使用递归的方法来写

```c++
class Solution {
public:
    ListNode* reverse(ListNode* pre, ListNode* cur){
        if(cur == NULL) return pre; //递归终止条件
        ListNode* tmp = cur->next;
        cur->next = pre;
        //pre = cur;
        //cur = tmp;
        return reverse(cur, tmp);
    }
    ListNode* reverseList(ListNode* head) {
    	//ListNode *pre = NULL;
    	//ListNode *cur = head;
    	return reverse(NULL, head);
    }
};
```

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**题意分析**

三指针法

三个指针分别指向交换的两个节点前后和当前节点。两两交换以后移动步长是2

通过设置一个虚拟节点，这样可以减少对头指针的操作。

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummy = new ListNode(-1);
        dummy -> next = head;
        ListNode *p1 = dummy; //p1是交换的两个节点的前一个节点
        //p2和p2->next 是要交换的节点
        ListNode *tmp, *tmp1;
        while(p1->next != NULL && p1->next->next != NULL){
            tmp = p1->next;
            tmp1 = p1->next->next->next;
            p1->next = p1->next->next;
            p1->next->next = tmp;
            p1->next->next->next = tmp1;

            p1=p1->next->next;
        }
        return dummy->next;
    }
};
```

递归法

递归三部曲：

1.确定递归的终止条件：链表为空或者链表只剩一个元素不需要交换

2.找返回值，需要返回上一层递归后的链表

3.单次递归过程：假设要交换的节点是p1，p2，p2需要接受上一个递归的返回值，

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;  //递归终止条件

        ListNode *p1 = head;
        ListNode *p2 = p1->next;
        p1->next = swapPairs(p2->next);
        p2->next = p1;
        return p2;
    }
};
```

